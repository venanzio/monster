\section{Monsters are Not Monads}


\vcomm{Counterexample showing that taking the diagonal as join doesn't work}

We show here that the naive and seemingly most natural way of defining monad operations on monsters doesn't satisfy the monad laws. \\

The Monad class has two methods: $\return$ and $\bind$:
$$
\begin{array}{l}
\return : A \rightarrow M\, A \\
(\bind) : M\, A \rightarrow (A \rightarrow M\, B) \rightarrow M\, B
\end{array}
$$
If a functor is a monad, it is an applicative functor. The correct definition for the $\return$ operation is always the same as that of $\apure$, and visa-versa. \\

A more categorical way of defining a monad is in terms $\join : M\,(M\, A) \rightarrow M\, A$.
$$
\join : M\,(M\, A) \rightarrow M\, A
$$

The $\bind$ operation can be defined in terms of $\join$, and visa-versa.
$$
\begin{array}{l}
(\bind\, f) = \join \comp M f \\
\join = (\bind\,\id)
\end{array}
$$

By showing that a natural definition of $\join$ does not satisfy the monad laws, we also show that the corresponding definition of $\bind$ does not either.

For a base functor $M$ the monad laws are as follows, where $a:A$, $m_a : M\, A$
$f : A \rightarrow M\, B$, $g : B \rightarrow M\,C$. We write these in terms of $\bind$, derived from Kleisli arrow composition and identity laws:
$$
\begin{array}{l@{\qquad}l}
(\return\, a)\, \bind \, f = f\, a
  & \mbox{Left identity} \\
m_a\, \bind \, \return = m_a
  & \mbox{Right identity} \\
(m_a \, \bind \, f)\, \bind \, g = m_a\, \bind\, (\lambda a.  f\, a \, \bind \, g)
  & \mbox{Composition} \\
\end{array}
$$

%\begin{haskell}
%tailM :: MonStr m a -> MonStr m a
%tailM = absorbM . tail
%
%join (MCons mma) = MCons $ do (mas, mma') <- mma
%                              let (ma, ts) = (head mas, fmap tailM mma')
%                                 in fmap (\a -> (a, join ts)) ma
%\end{haskell}

Our naive implementation of $\join$ is to take the 'diagonal' to flatten a monadic stream of monsters. This means taking the first element of the first monster, the second element of the second monster, and so on. We first define three auxiliary functions:
$$
\begin{array}{l}
\mathsf{uncons} : \stream{M}\,A \rightarrow M\,(A \times \stream{M}\,A)\\
\mathsf{uncons} (\mcons\, m_a) = m_a \\
\,\\
\mathsf{absorb} : M\,(\stream{M}\,A) \rightarrow \stream{M}\,A \\
\mathsf{absorb} =  \mcons \comp \join \comp M\,\mathsf{uncons} \\
\,\\
\mathsf{tailM} : \stream{M}\,A \rightarrow \stream{M}\,A \\
\mathsf{tailM} = \mathsf{absorb} \comp \tail \comp \mathsf{uncons}
\end{array}
$$

The definition of $\join$ is as follows, where $s, ts : \stream{M}\,(\stream{M}\, A)$, 
$hs : \stream{M}\, A$, $a : M\, A$
$$
\join\, s = s \, \bind \,(\lambda \pair{hs}{ts} . M\,(\lambda a . \pair{a}{(\join \comp M\,\mathsf{tailM})\, ts})\, (\head\, hs))
$$
We introduce the type $\state\stream{S} = \stream{\state_S}$, where $\state_S A = S \rightarrow A \times S$, representing the $\state$ functor with states of type $S$, and return values of type $A$. We assume it is equipped with the usual monad operations for the $\state$ monad. We call these types of monsters (those with an underlying $\state$ monad) state machines.
$$
\begin{array}{l}
\fromstepstr : \nat \rightarrow \state\stream{\nat}\,\nat \\
\fromstepstr\, n = \mcons (\lambda s. \pair{\pair{s}{\fromstepstr (n + 1)}}{s + n})
\end{array}
$$
This function generates a state machine which, when given a number, generates a stream where the first two numbers differ by $n$, the next two differ by $n + 1$, and so on.



