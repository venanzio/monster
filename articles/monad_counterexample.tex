\section{Investigating Monadic Monsters}\label{sec:monad}

A spontaneous question to ask next is whether the $\stream{M}$ type constructor is not just an applicative functor, but also a monad, if the underlying functor $M$ is.

Let us recall the definition: a {\em monad}
is a functor $M$ with two methods: a $\return$ function injecting pure elements into $M$ and either a $\join$ or a bind ($\bind$) operation sequencing monadic actions, satisfying three laws.
$$
\begin{array}{l}
\return : A \rightarrow M\, A \\
\join : M\,(M\, A) \rightarrow M\, A\\
\mbox{ or }
(\bind) : M\, A \rightarrow (A \rightarrow M\, B) \rightarrow M\, B
\end{array}
$$

The version using the $\join$ operation is common in the categorical literature, while the version using $(\bind)$ is more convenient in functional programming.
They can be defined in terms of each other:
$$
(m_a \bind\, f) = \join \, (M f\, m_a) \qquad
\join\, m = m \bind\,\id
$$

We already know that some specific specific choices of the underlying monad $M$  result in monadic monsters.
For example, $\maybe$-monsters (lazy lists) are a monad by defining $\join$ as the concatenation of a list of lists, and $\Id$-monsters (pure streams) are a monad by defining $\join$ as the diagonal of a stream of streams.

One might think that taking the diagonal could work for any $M$-monster where $M$ is a monad. We show that, at least for one definition of taking the diagonal, this is not the case in general by giving a counterexample for $\state$-monsters.\\

We naturally take $\return_{\stream{M}}$ to be the same as $\apure_{\stream{M}}$.
The idea of the implementation of the proposed $\join_{\stream{M}}$ operation is that,
given a {\em monster matrix} $\mu:\stream{M}\,(\stream{M}\,A)$, we travel down the diagonal and pick elements in positions $(0,0)$, $(1,1)$, $(2,2)$, etc.
This seems the most sensible approach as it generalizes the canonical $\join_\strsym$ operation of the pure stream monad.
However, since these are monadic streams, accessing those elements requires executing all the monadic actions leading to them.

In order to state this definition of $\join_{\stream{M}}$ formally, let us introduce some notation.
We use $\unc{\sigma}$ to denote the monadic action associated to the monster $\sigma$, that is $ \unc{\sigma} = \uncons\,\sigma $, just stripping the $\mcons$ constructor away.
The $\head_M$ and $\tail_M$ functions extract the components of a monster, but of course they can only return a value inside the monad $M$.

$$
\begin{array}{l}
\uncons : \stream{M}\,A \rightarrow M\,(A \times \stream{M}\,A)\\
\uncons\, (\mcons\, m_a) = m_a \\
\,\\
\unc{-} : \stream{M}\,A \rightarrow M\,(A\times \stream{M}\,A)\\
\unc{\sigma} = \uncons\,\sigma
\end{array}
\qquad
\begin{array}{l}
\head_M : \stream{M}\,A \rightarrow M\,A\\
\head_M = M\,\fst \comp \uncons\\
\,\\
\tail_M : \stream{M}\,A \rightarrow M\,(\stream{M}\,A)\\
\tail_M = M\,\snd \comp \uncons\\
\end{array}
$$

When we traverse a monster to get to its elements, we have to use monadic actions, so we don't get pure elements.
That's the case for $\head_M$ and $\tail_M$ above.
However, a monadic action can always be absorbed inside a monster, by using the $\join$ operation for $M$.
This allows us to define a ``pure'' version of the $\tail_M$ function, which we call $\traverse_M$.
We first define four auxiliary functions:

$$
\begin{array}{l}
\absorb_M : M\,(\stream{M}\,A) \rightarrow \stream{M}\,A \\
\absorb_M =  \mcons \comp \join_{M} \comp M\,\uncons
\end{array}
  \qquad
\begin{array}{l}
\traverse_M : \stream{M}\,A \rightarrow \stream{M}\,A \\
\traverse_M = \absorb_M \comp \tail_M \comp \uncons
\end{array}
$$

We are ready to give the definition of $\join$:
$$
\begin{array}{ll}
\multicolumn{2}{l}{\join: \stream{M}\,(\stream{M}\,A) \rightarrow \stream{M}\,A}\\
\join\,\mu = \mcons\,(
  & \unc{\mu} \bind
    \lambda \pair{\sigma_a}{\mu'}.\\
  &  (\head\,\sigma_a) \bind \lambda a.\\
  & \return\,\pair{a}{\join\,(\stream{M}\,\traverse\, \mu')} \; )
\end{array}
$$

There is some degree of unpacking, but ultimately, given a monster matrix $\mu$, we get its components, the first row $\sigma_a$ and the rest of the matrix $\mu'$; 
we extract the first element $a$ from $\sigma_a$;
we map $\traverse_M$ onto $\mu'$ to delete the first column, then we corecursively apply $\join_{\stream{M}}$.

Keeping in mind that the functorial mapping for a monad is defined as $M\,f\,m_a = m_a \bind \lambda a. \return\,(f\,a)$ and rearranging the expression a bit, we have this equivalent one-line characterization:
$$
\join_{\stream{M}}\, \mu = \mcons\, (\unc{\mu} \, \bind \,(\lambda \pair{\sigma_a}{\mu'} . M\,(\lambda a . \pair{a}{(\join_{\stream{M}}\, \comp\, \stream{M}\,\traverse_M)\, \mu'})\, (\head_M\, \sigma_a)))
$$

We now present our counterexample: a $\state$-monster that violates one of the monad laws.
$$
\begin{array}{l}
\fromstepstr : \nat \rightarrow \stmon{\nat}\,\nat \\
\fromstepstr\, n = \mcons\, (\lambda s. \pair{\pair{s}{\fromstepstr (n + 1)}}{s + n})
\end{array}
$$
This function generates a state machine which, when given a number, generates a stream where the first two numbers differ by $n$, the next two differ by $n + 1$, and so on.

You can `run' this state machine by threading an initial seed state $s$ through each nested function, `mutating' the state with each function call, and collecting the results in a pure stream:
$$
\begin{array}{l}
\strun : \stmon{S}\,A \rightarrow S \rightarrow \stream{\Id}\,A  \\
\strun\, m\, s = a \acons (\strun\,m'\,s')  \\
\qquad\where\,\pair{\pair{a}{m'}}{s'} = (\uncons\,m)\, s
\end{array}
$$

For example:

$$
\strun\,(\fromstepstr\, 1)\, 2 = 2\, \acons\, 3\, \acons\, 5\, \acons\, 8\, \acons\, 12\, \acons\, \dots
$$

We now show that this specific case of the left identity monad law does not hold, by `running' both sides.
$$
(\join_{\stmon{\nat}} \comp \stmon{\nat}\, \fromstepstr \comp \return)\, n = \fromstepstr\, n
$$
By constructing the monster on the left-hand side of this equation when $n = 1$, and `running' it with a seed state of $2$, we should obtain the same resultant stream as from $\strun\,(\fromstepstr\, 1)\, 2$. Instead we obtain:
$$
\strun\, ((\join_{\stmon{\nat}} \comp \stmon{\nat}\, \fromstepstr \comp \return)\, 1)\, 2 = 2\, \acons\, 4\, \acons\, 9\, \acons\, 18\, \acons\, 32\, \acons\, \dots
$$
By extensionality, it is clear that the monsters on either side of the equality in question cannot be the same, therefore the left identity law does not hold for this definition of $\join_{\stream{M}}$.

Code demonstrating this counterexample is included within our library \ccomm{link to the library here}. 




