\section{Investigating Monadic Monsters}\label{sec:monad}

A spontaneous question to ask next is whether the $\stream{M}$ type constructor is not just an applicative functor, but also a monad, if the underlying functor $M$ is.

Let us recall the definition: a {\em monad}
is a functor $M$ with two methods: a $\return$ function injecting pure elements into $M$ and either a $\join$ or a bind ($\bind$) operation sequencing monadic actions, satisfying three laws.
$$
\begin{array}{l}
\return : A \rightarrow M\, A \\
\join : M\,(M\, A) \rightarrow M\, A\\
\mbox{ or }
(\bind) : M\, A \rightarrow (A \rightarrow M\, B) \rightarrow M\, B
\end{array}
$$

The version using the $\join$ operation is common in the categorical literature, while the version using $(\bind)$ is more convenient in functional programming.
They can be defined in terms of each other:
$$
(m_a \bind\, f) = \join \, (M f\, m_a) \qquad
\join\, m = (m \bind\,\id)
$$


The laws can be expressed either in terms of $\join$ or $(\bind)$.
The following is the formulation in terms of $(\bind)$.
Let $a:A$, $m_a : M\, A$,
$f : A \rightarrow M\, B$, $g : B \rightarrow M\,C$:

$$
\begin{array}{l@{\qquad}l}
(\return\,a \bind  f) = f\, a
  & \mbox{Left identity} \\
(m_a \bind \return) = m_a
  & \mbox{Right identity} \\
((m_a \bind f) \bind g) = (m_a \bind (\lambda a.  f\, a  \bind  g))
  & \mbox{Composition} \\
\end{array}
$$

A monad is automatically an applicative functor:
$\apure$ is the same as $\return$ and $\appl$ can be defined as:
$
m_f\appl m_a = m_f \bind (\lambda f. m_a \bind (\lambda a. f\,a))
$

We already know that some specific specific choices of the underlying monad $M$  result in monadic monsters.
For example, $\maybe$-monsters (lazy lists) are a monad by defining $\join$ as the concatenation of a list of lists, and $\Id$-monsters (pure streams) are a monad by defining $\join$ as the diagonal of a stream of streams.

It is possible, and intuitively reasonable, to extend the monad instantiation for pure streams to all $M$-monsters where $M$ is a monad:
define $\return$ as repetition of an element, the same as $\apure_{\stream{M}}$;
define $\join$ to be the diagonal of a {\em monster matrix}, that is, a monster of monsters.

Unfortunately, this instantiation does not satisfy the monad laws universally: we will give a counterexample using $\state$-monsters.

The idea of the implementation of the proposed $\join_{\stream{M}}$ operation is that,
given a {\em monster matrix} $\mu:\stream{M}\,(\stream{M}\,A)$, we travel down the diagonal and pick elements in positions $(0,0)$, $(1,1)$, $(2,2)$, etc.
This seems the most sensible approach as it generalizes the canonical $\join_\strsym$ operation of the pure stream monad.
However, since these are monadic streams, accessing those elements requires executing all the monadic actions leading to them.

In order to state this definition of $\join_{\stream{M}}$ formally, let us introduce some notation.
We use $\unc{\sigma}$ to denote the monadic action associated to the monster $\sigma$, that is $ \unc{\sigma} = \uncons\,\sigma $, just stripping the $\mcons$ constructor away.
The $\head_M$ and $\tail_M$ functions extract the components of a monster, but of course they can only return a value inside the monad $M$.

$$
\begin{array}{l}
\uncons : \stream{M}\,A \rightarrow M\,(A \times \stream{M}\,A)\\
\uncons\, (\mcons\, m_a) = m_a \\
\,\\
\unc{-} : \stream{M}\,A \rightarrow M\,(A\times \stream{M}\,A)\\
\unc{\sigma} = \uncons\,\sigma
\end{array}
\qquad
\begin{array}{l}
\head_M : \stream{M}\,A \rightarrow M\,A\\
\head_M = M\,\fst \comp \uncons\\
\,\\
\tail_M : \stream{M}\,A \rightarrow M\,(\stream{M}\,A)\\
\tail_M = M\,\snd \comp \uncons\\
\end{array}
$$

When we traverse a monster to get to its elements, we have to use monadic actions, so we don't get pure elements.
That's the case for $\head_M$ and $\tail_M$ above.
However, a monadic action can always be absorbed inside a monster, by using the $\join$ operation for $M$.
This allows us to define a ``pure'' version of the $\tail_M$ function, which we call $\tailm_M$.
We first define four auxiliary functions:

$$
\begin{array}{l}
\absorb_M : M\,(\stream{M}\,A) \rightarrow \stream{M}\,A \\
\absorb_M =  \mcons \comp \join_{M} \comp M\,\uncons
\end{array}
  \qquad
\begin{array}{l}
\tailm_M : \stream{M}\,A \rightarrow \stream{M}\,A \\
\tailm_M = \absorb_M \comp \tail_M
\end{array}
$$

With the help of these unpacking functions, we define $\join$ for ${\stream{M}}$:
$$
\begin{array}{ll}
\multicolumn{2}{l}{\join_{\stream{M}}: \stream{M}\,(\stream{M}\,A) \rightarrow \stream{M}\,A}\\
\join_{\stream{M}}\,\mu = \mcons\,(
  & \unc{\mu} \bind
    \lambda \pair{\sigma_a}{\mu'}.\\
  &  (\head\,\sigma_a) \bind \lambda a.\\
  & \return\,\pair{a}{\join_{\stream{M}}\,(\stream{M}\,\tailm\, \mu')} \; )
\end{array}
$$
Given a monster matrix $\mu$, we decompose it into its first row $\sigma_a$ and the rest of the matrix $\mu'$; 
we extract the first element $a$ from $\sigma_a$;
we map $\tailm_M$ onto $\mu'$ to delete the first column, then we corecursively apply $\join_{\stream{M}}$.

We now present our counterexample: a $\state$-monster that violates one of the monad laws.
$$
\begin{array}{l}
\fromstepstr : \nat \rightarrow \stmon{\nat}\,\nat \\
\fromstepstr\, n = \mcons\, (\lambda s. \pair{\pair{s}{\fromstepstr (n + 1)}}{s + n})
\end{array}
$$
When we apply this function to an initial increment $n$, it generates a state machine that will output the value of the state and increment the state by $n$; then it calls itself with the increment increased by 1.

You can `run' this state machine by threading an initial seed state $s$ through each nested function, `mutating' the state with each function call, and collecting the results in a pure stream:
$$
\begin{array}{l}
\strun : \stmon{S}\,A \rightarrow S \rightarrow \stream{\Id}\,A  \\
\strun\, m\, s = a \acons (\strun\,m'\,s')  \\
\qquad\where\,\pair{\pair{a}{m'}}{s'} = (\uncons\,m)\, s
\end{array}
$$

For example, running $\fromstepstr$ with initial increment $1$ and starting state $2$:
$$
\strun\,(\fromstepstr\, 1)\, 2 = 2\, \acons\, 3\, \acons\, 5\, \acons\, 8\, \acons\, 12\, \acons\, \dots
$$

We know show that the left identity monad law does not hold for $\stmon{S}$ using the diagonal definition of $\join$.
The law states that:
$$
(\join_{\stmon{\nat}} \comp \stmon{\nat}\, \fromstepstr \comp \return)\, n = \fromstepstr\, n
$$
If it were true, running the left-hand side with $n = 1$ and initial state $2$ should give us the same pure stream as before.
Instead we have:
$$
\strun\, ((\join_{\stmon{\nat}} \comp \stmon{\nat}\, \fromstepstr \comp \return)\, 1)\, 2 = 2\, \acons\, 4\, \acons\, 9\, \acons\, 18\, \acons\, 32\, \acons\, \dots
$$
Therefore the monsters on either side of the equality in question cannot be the same and the left identity law does not hold for this definition of $\join_{\stream{M}}$.

Code demonstrating this counterexample is included with the library in the file {\tt Tests/MonadCounterExamples.hs}.

The counterexample shows that the {\em diagonal} definition of $\join$ does not yield a universal monad instantiation for monsters. 
It still may work for specific base monads $M$, as for $\Id$.
For other base functors, a different instantiation may work, for example the {\em concatenation} implementation for $\maybe$-monsters.
