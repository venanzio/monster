\documentclass[runningheads]{llncs}

\bibliographystyle{splncs04}

\usepackage{amssymb,amsmath}      %,amsthm}
\usepackage{pstricks,pst-node}

\usepackage{notations}


\begin{document}

\title{Type Classes of Monsters}

\author{Venanzio Capretta\inst{1} \and
        Christopher Purdy\inst{1}}


\authorrunning{V. Capretta and C. Purdy}

\institute{Nottingham University, UK
          \email{\{venanzio.capretta,psycjpu\}@nottingham.ac.uk}}

\maketitle


\newtheorem{lemmainner}{Lemma}
\newenvironment{lemmaa}[1]{%
  \renewcommand\thelemmainner{#1}%
  \lemmainner
}{\endlemmainner}

\begin{abstract}
A monadic stream (which we call a {\em monster}) is a potentially infinite sequence of values in which every element triggers a monadic action.
Monsters are useful tools in functional programming: they can be instantiated to pure streams, lazy lists, finitely branching trees, interactive processes, state machines, and many other data structures.
We developed an extensive library of generic functions for monsters in Haskell.
We prove that if the underlying functor is applicative, the monster constructor is also an applicative functor.
Functoriality is straightforward, but the applicative laws require a series of complex lemmas about the behaviour of sequential composition under a monad and through corecursion.
On the other hand, monsters do not form a monad in a straightforward way, even if the underlying functor is itself a monad.
We show that the generalization of the join operation from pure streams (by taking the diagonal of a stream of streams) does not satisfy the monad laws.
\end{abstract}

\input{introduction}
\input{functor}
\input{applicative}
\input{monad_counterexample}
\input{conclusions}

\bibliography{monster_biblio.bib}

\appendix
\input{appendix}

\end{document}
