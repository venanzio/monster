\section{Monsters are Applicatives}\label{sec:applicative}

Applicative functors \cite{mcbride/paterson:2008}
extend the mapping operation by allowing function sequencing under the functor.
The Applicative class has two methods: $\apure$, that injects single values into the functor, and $\appl$, that applies functions under the functor:
$$
\begin{array}{l}
\apure : A \rightarrow M\,A\\
(\appl): M\,(A\rightarrow B) \rightarrow M\,A \rightarrow M\,B
\end{array}
$$
They must satisfy the four applicative laws given below (after we introduce some notation).

A typical use of applicative functors is to apply a function of many arguments to several applicative values.
If $g:A_0\rightarrow A_1 \rightarrow \cdots \rightarrow A_n \rightarrow B$ and $m_0:M\,A_0, m_1:M\,A_1, \ldots, m_n:M\,A_n$ , then:
$$
\apure\,g \appl m_0 \appl m_1 \appl \cdots \appl m_n : M\,B
$$

In particular, if $g$ is an infix binary operator $(\oplus) : A \rightarrow B \rightarrow C$, we can lift it to $M$-objects:
$$
m_a \alift{\oplus} m_b 
= \apure\,(\oplus) \appl m_a \appl m_b
$$

Here are the applicative functor laws for $M$, where
 $a:A$, $f:A\rightarrow B$,
$m_a:M\,A$, $m_f:M\,(A\rightarrow B)$, $m_g:M\,(B\rightarrow C)$.
$$
\begin{array}{l@{\qquad}l}
\apure\,\id \appl m_a = m_a
  & \mbox{Identity} \\
\apure\,f \appl \apure\,a = \apure\,(f\,a)
  & \mbox{Homomorphism} \\
m_f \appl \apure\,a = \apure\,(\lambda f. f\,a) \appl m_f
  & \mbox{Interchange} \\
m_g \appl (m_f \appl m_a) = (m_g \alift{\comp} m_f) \appl m_a
  & \mbox{Composition}
\end{array}
$$

A consequence of the Homomorphism and Composition Laws is that sequential application of functions can be reduced to a single application of the composition;
if $g:B\rightarrow D$ and $h:A_1\rightarrow A_2 \rightarrow C$, then:
$$
\begin{array}{l}
\apure\,g \appl (\apure\, f \appl m_a) = \apure\, (g\comp f) \appl m_a\\
\apure\,g \appl (\apure\, h \appl m_{a_1} \appl m_{a_2})
  = \apure\, (\lambda a.\lambda b. g\,(h\,a\,b)) \appl m_{a_1} \appl m_{a_2}
\end{array}
$$

Functoriality of $M$ follows from these laws, with functorial mapping defined as
$
M\,f\,m_a = \apure\,f \appl m_a.
$
The homomorphism law implies that
$
M\,f\,(\apure\,a) = \apure\,(f\,a).
$

The two previous observations validate the following characterization of the applicative lifting of a binary operator
 ($\pairing$ is the pairing operator, $\pairing\,a\,b = \pair{a}{b}$, and $\pairop{\oplus}$ operates on pairs, $\pairop{\oplus}\,\pair{a}{b} = a \oplus b$):
$$
\begin{array}{rl}
m_a \alift{\oplus} m_b 
& {} = \apure\,(\pairop{\oplus}) \appl (\apure\,\pairing\appl m_a\appl m_b) \\
& {}= M\,(\pairop{\oplus})\,(\apure\,\pairing\appl m_a\appl m_b)
\end{array}
$$

We will show that $\stream{M}$ is also applicative.
In order to define the methods, we need some auxiliary functions.
First of all, simplified versions of $\mcons$: appending either an $M$-action or a pure value in front of a monster.
The first works when $M$ is just a functor, the second when it is an applicative:
$$
\begin{array}{l}
(\fcons): M\,A \rightarrow \stream{M}\,A \rightarrow \stream{M}\,A\\
m \fcons \sigma = \mcons\, (M\,(\lambda a. \langle a, \sigma\rangle)\,m)
\end{array}\qquad
\begin{array}{l}
(\acons): A \rightarrow \stream{M}\,A \rightarrow \stream{M}\,A\\
a \acons \sigma = (\apure\, a) \fcons \sigma
\end{array}
$$

The $\apure$ method for monsters repeats the same element forever:
$$
\begin{array}{l}
\apure : A \rightarrow \stream{M}\,A\\
\apure\,a = a \acons \apure\,a
\end{array}
$$
To check that the recursive occurrence of $\apure\,a$ satisfies the guardedness condition we just unfold the definitions (we write the functor as a subscript to clarify which version of $\apure$ is used):
$$
\begin{array}{ll}
\apure_{\stream{M}}\,a 
& {} = a \acons \apure_{\stream{M}}\,a 
     = (\apure_M\, a) \fcons \apure_{\stream{M}}\,a \\
& {} = \mcons\, (M\,(\lambda a. \langle a, \apure_{\stream{M}}\,a \rangle)\, (\apure_M\, a))
\end{array}
$$
The recursive occurrence of $\apure_{\stream{M}}\,a$ is guarded by $\mcons$ and the functorial application of $M$.
The occurrence of $(\apure_M\, a)$ on the other hand. is not recursive and therefore unproblematic.

The homomorphism law for $M$ provides a further simplification.
\begin{lemma}\label{lemma:monster_pure} 
$$
\apure_{\stream{M}}\,a = \mcons\,(\apure_M\,\langle a, \apure_{\stream{M}}\,a\rangle)
$$
\end{lemma}

The previous discussion shows that the second arguments of $(\fcons)$ and $(\acons)$, when definitions are expanded, are guarded by the constructor $\mcons$.
Therefore, in future definitions and proofs, we allow ourselves to give corecursive definitions as that for $\apure\,a$ without justifying them by expansion.

In the following statements and proofs, we often need to write terms that combine the use of $\apure$ on $M$ and on $\stream{M}$.
This could be confusing, so we explicitly write the functors as subscript: $\apure_M$ and $\apure_{\stream{M}}$.
We also explicitly write the type of identity functions as a subscript.
We consistently use $\sigma$ with subscripts to denote monsters and $m$ with subscripts to denote $M$-actions.
We adopt the convention that $\apure$ binds stronger than any of the infix operators that we use, specifically $\appl$, $\alift{\comp}$ and $\alift{\pappl}$ (defined below).


We define the function application method by mapping straight function application on the heads and recursive calls on the tails through functorial and applicative lifting:

$$
\begin{array}{l}
(\appl) : \stream{M}\,(A\rightarrow B) \rightarrow \stream{M}\,A \rightarrow \stream{M}\,B\\
(\mcons\,m_f) \appl (\mcons\,m_a)
= \mcons\,(m_f \alift{\pappl} m_a)\\
\qquad \where\;
\langle f,\phi\rangle \pappl \langle a,\sigma\rangle 
= \langle f\,a, \phi \appl \sigma \rangle
\end{array}
$$

This definition recursively applies $\appl$ indirectly in the second components of the arguments of the $\pappl$ operator.
This is lifted to $\alift{\pappl}$, which distributes down through the components of the applicative values $m_f$ and $m_a$, and finally guarded by the constructor $\mcons$.
This guarantees the soundness of the definition according to the {\em guardedness-by-constructors} criterion.
(Formally, we can rewrite the definition, using the previous characterization of the applicative lifting of a binary operator, to reduce it to a syntactically guarded form.)

We aim to show that these definitions satisfy the applicative laws.
We assume that the laws hold for the base functor $M$ and we wish to prove them for the monster functor $\stream{M}$.

The new operator $\alift{\pappl}$ has a direct simplification on pure values, which will be very useful in the proofs of the laws.
\begin{lemma}\label{lemma:pappl}
If $f:A\rightarrow B$, $m_f:\stream{M}\,(A\rightarrow B)$, $a:A$, $m_a:\stream{M}\,A$, then:
$$
\apure_M\,\langle f, m_f\rangle \alift{\pappl} \apure_M\,\langle a, m_a\rangle = \apure_M \langle f\,a, m_f \appl m_a \rangle
$$
\end{lemma}
\begin{proof}
By definition of ${}\alift{-}{}$ and the homomorphism law for $M$.
\end{proof}

\begin{lemma}
Monsters satisfy the applicative identity law:
$$
\apure_{\stream{M}}\,\id_A \appl \sigma_a = \sigma_a
$$
\end{lemma}
\begin{proof}
Assume that $\sigma_a$ has the canonical form:
$\sigma_a = \mcons\,m$ where $m:M\,(A\times \stream{M}A).$
Most of the proof is by straightforward equational reasoning, unfolding definitions and using the applicative laws for $M$.

The only unusual step is the application of the {\em coinduction hypothesis}.
Recall that this means that we can assume that the statement to prove is already true, as long as it is invoked only on direct arguments of the monster constructor.
Specifically, we can invoke it on the recursive application $\phi \appl \sigma$ in the definition of $\appl$, since that occurrence is guarded.

By expanding definitions and using the interchange and homomorphism laws for $M$ we obtain:
$$
\apure_{\stream{M}}\,\id_A \appl \sigma_a \\
= \mcons\,(\apure_M\,(\lambda \langle a,\sigma_a\rangle. \langle \id_A\,a, \apure_{\stream{M}}\,\id_A \appl \sigma_a\rangle) \appl m)
$$
The recursive occurrence $\apure_{\stream{M}}\,\id_A \appl \sigma_a$ is guarded, therefore we can apply the coinductive hypothesis to it:
$$
\cdots = \mcons\,(\apure_M\,(\lambda \langle a,\sigma_a\rangle. \langle a, \sigma_a\rangle) \appl m)
$$
this trivially reduces to $(\mcons\,m) = \sigma_a$, as desired.
\hide{
$$
\begin{array}{ll}
\apure_{\stream{M}}\,\id_A \appl \sigma_a \\
{}= (\id_A \acons (\apure_{\stream{M}}\,\id_A)) \appl \sigma_a
  & \mbox{definition of }\apure \\
{}= ((\apure_M\,\id_A) \fcons (\apure_{\stream{M}}\,\id_A)) \appl \sigma_a
  & \mbox{definition of }\acons \\
{}= (\mcons\,(M\,(\lambda f. \langle f, \apure_{\stream{M}}\,\id_A\rangle)\,(\apure_M\,\id_A))) \appl \sigma_a
  & \mbox{definition of }\fcons \\
{}= (\mcons\,(\apure_M\,\langle \id_A, \apure_{\stream{M}}\,\id_A \rangle)) \appl \sigma_a
  & \mbox{interchange law for }M \\
{}= (\mcons\,(\apure_M\,\langle \id_A, \apure_{\stream{M}}\,\id_A\rangle)) \appl (\mcons\,m)
  & \mbox{canonical form of }\sigma_a\\
{}= \mcons\,(\apure_M\,\langle \id_A, \apure_{\stream{M}}\,\id_A\rangle)) \alift{\pappl}  m)
  & \mbox{definition of }\appl \\
{}= \mcons\,(\apure_{M}\,(\pappl) \appl \apure_M\,\langle \id_A, \apure_{\stream{M}}\,\id_A\rangle \appl  m)
  & \mbox{definition of }\alift{-} \\
{}= \mcons\,(\apure_M\,((\pappl)\,\langle \id_A, \apure_{\stream{M}}\,\id_A\rangle) \appl  m)
  & \mbox{homomorphism law for }M\\
{}= \mcons\,(\apure_M\,(\lambda \langle a,\sigma_a\rangle. \langle \id_A, \apure_{\stream{M}}\,\id_A\rangle \pappl \langle a,\sigma_a\rangle) \appl m)
  & \mbox{expansion of the section}\\
{}= \mcons\,(\apure_M\,(\lambda \langle a,\sigma_a\rangle. \langle \id_A\,a, \apure_{\stream{M}}\,\id_A \appl \sigma_a\rangle) \appl m)
  & \mbox{definition of }\pappl\\
{}= \mcons\,(\apure_M\,(\lambda \langle a,\sigma_a\rangle. \langle a, \sigma_a\rangle) \appl m)
  & \mbox{coinduction hypothesis}\\
{}= \mcons\,(\apure_M\,\id_{A\times\stream{M}A} \appl m)
  & \mbox{trivial}\\
{}= \mcons\,m = \sigma_a
  & \mbox{identity law for }M
\end{array}
$$

In the step that makes use of the coinduction hypothesis, we circularly use the lemma's statement that $\apure_{\stream{M}}\,\id_A \appl \sigma_a = \sigma_a$.
The right-hand side occurs under an application of the constructor $\mcons$, inside an application of a pure value. 
This structural positioning of the term ensure that the application of the coinductive hypothesis is sound.}
\end{proof}

\begin{lemma}
Monsters satisfy the applicative homomorphism law:
$$
\apure_{\stream{M}}\,f \appl \apure_{\stream{M}}\,a = \apure\,(f\,a)
$$

\end{lemma}
\begin{proof}
By definiton of $\appl$ and Lemmas \ref{lemma:monster_pure} and \ref{lemma:pappl} we have:
$$
\apure_{\stream{M}}\,f \appl \apure_{\stream{M}}\,a
= \mcons\,(\apure_M\,\langle f\, a, \apure_{\stream{M}}\,f \appl \apure_{\stream{M}}\,a \rangle))
$$
We can now apply the coinduction hypthesis to the guarded occurrence of $\apure_{\stream{M}}\,f \appl \apure_{\stream{M}}\,a$ to obtain:
$$
\cdots = \mcons\,(\apure_M\,\langle f\,a, \apure_{\stream{M}}\,(f\,a)\rangle)
$$
witch simplifies, using Lemma \ref{lemma:monster_pure} again, to $\apure_{\stream{M}}\,(f\,a)$, as desired.
\hide{
$$
\begin{array}{ll}
\apure_{\stream{M}}\,f \appl \apure_{\stream{M}}\,a\\
{}= (\mcons\,(\apure_M\,\langle f, \apure_{\stream{M}}\,f\rangle)) \appl
    (\mcons\,(\apure_M\,\langle a, \apure_{\stream{M}}\,a\rangle))
  & \mbox{Lemma \ref{lemma:monster_pure}}\\
{}= \mcons\,(\apure_M\,\langle f, \apure_{\stream{M}}\,f\rangle \alift{\pappl}
             \apure_M\,\langle a, \apure_{\stream{M}}\,a\rangle)
  & \mbox{definition of }\appl\\
{}= \mcons\,(\apure_M\,\langle f\, a, \apure_{\stream{M}}\,f \appl \apure_{\stream{M}}\,a \rangle))
  & \mbox{Lemma }\ref{lemma:pappl}\\
{}= \mcons\,(\apure_M\,\langle f\,a, \apure_{\stream{M}}\,(f\,a)\rangle)
  & \mbox{coinduction hypothesis}\\
{}= \apure_{\stream{M}}\,(f\,a)
  & \mbox{lemma }\ref{lemma:monster_pure}
\end{array}
$$}
\end{proof}

The following lemma gives two technical equalities that are very useful the proof of the last two applivative laws for monsters.
They can be proved by equational manipulations using the definition of the operators and the applicative laws for $M$.

\begin{lemma}\label{lemma:pure_lift}% \label{lemma:applicative_flip}
Let $a:A$, $m_a : M\, A$, $b:B$, $(\oplus) : A \rightarrow B \rightarrow C$, $f : A \rightarrow B \rightarrow C$. Then:
$$
\begin{array}{l}
\apure_M\, a \alift{\oplus} \apure_M\, b = \apure_M\, (a \oplus b)\\
\apure_M\, f \appl m_a \appl \apure_M\, b = \apure_M\, (\lambda a . f\, a\, b) \appl m_a
\end{array}
$$
\end{lemma}

\begin{lemma}
Monsters satisfy the applicative interchange law.
 If $\sigma_f: \stream{M}(A\rightarrow B)$ and $a:A$, then:
$$
\sigma_f \appl \apure_{\stream{M}}\,a = \apure_{\stream{M}}\,(\lambda f. f\,a) \appl \sigma_f
$$
\end{lemma}
\begin{proof}
Assume that $\sigma_f = \mcons\,m_f$ for some $m_f:M\,((A\rightarrow B)\times \stream{M}\,(A\rightarrow B))$.
By definition of the operators and Lemmas \ref{lemma:monster_pure} and \ref{lemma:pure_lift} we can rewrite the right-hand side to:
$$
\sigma_f \appl \apure_{\stream{M}}\,a
= \mcons\,(\apure_M\,(\lambda \pair{f}{\phi} . \pair{f a}{\phi \appl \apure_{\stream{M}}\,a}) \appl m_f)
$$
We apply the coinduction hypothesis to the guarded occurrence of $\phi \appl \apure_{\stream{M}}\,a$:
$$
\ldots = \mcons\,(\apure_M\,(\lambda \pair{f}{\phi} . \pair{f a}{\apure_{\stream{M}}\,(\lambda f . f\, a) \appl \phi}) \appl m_f)
$$
Using the homomorphism law for $M$ and Lemma \ref{lemma:monster_pure}, this further reduces to $\apure_{\stream{M}}\,(\lambda f. f\,a) \appl \sigma_f$, as desired.
\hide{
$$
\begin{array}{ll}
\sigma_f \appl \apure_{\stream{M}}\,a = (\mcons\,m_f) \appl \apure_{\stream{M}}\,a \\
{}= (\mcons\,m_f) \appl (\mcons\,(\apure_M\,\langle a, \apure_{\stream{M}}\,a\rangle))
  & \mbox{Lemma \ref{lemma:monster_pure}}\\
{}= \mcons\,(m_f \alift{\pappl} \apure_M\,\langle a, \apure_{\stream{M}}\,a\rangle)
  & \mbox{definition of }\appl\\
{}= \mcons\,(\apure_M\,(\pappl) \appl m_f \appl \apure_M\,\langle a, \apure_{\stream{M}}\,a\rangle)
  & \mbox{definition of }\alift{-}\\
{}= \mcons \, (\apure_M\,(\lambda \pair{f}{\phi} . \pair{f}{\phi} \pappl \pair{a}{\apure_{\stream{M}}\,a}) \appl m_f)
  & \mbox{Lemma \ref{lemma:pure_lift}}\\
{}= \mcons\,(\apure_M\,(\lambda \pair{f}{\phi} . \pair{f a}{\phi \appl \apure_{\stream{M}}\,a}) \appl m_f)
  & \mbox{definition of } \pappl \\
{}= \mcons\,(\apure_M\,(\lambda \pair{f}{\phi} . \pair{f a}{\apure_{\stream{M}}\,(\lambda f . f\, a) \appl \phi}) \appl m_f)
  & \mbox{coinduction hypothesis} \\
{}= \mcons\,(\apure_M\,(\lambda \pair{f}{\phi}.
    \pair{\lambda f . f\, a}{\apure_{\stream{M}}\,(\lambda f . f\, a))}
    \pappl \pair{f}{\phi}
    ) \appl m_f)
  & \mbox{definition of } \pappl \\
{}= \mcons\,(\apure_M\,(\pappl) \appl \apure_M\,\langle \lambda f. f\,a, \apure_{\stream{M}}\,(\lambda f. f\,a)  \rangle \appl m_f)
  & \mbox{homomorphism law for }M \\
{}= \mcons\,(\apure_M\,\langle \lambda f. f\,a, \apure_{\stream{M}}\,(\lambda f. f\,a)  \rangle \alift{\pappl} m_f)
  & \mbox{definition of }\alift{-}\\
{}= (\mcons\,(\apure_M\,\langle \lambda f. f\,a, \apure_{\stream{M}}\,(\lambda f. f\,a)  \rangle)) \appl (\mcons\,m_f)
  & \mbox{definition of }\appl \\
{}= \apure_{\stream{M}}\,(\lambda f. f\,a) \appl (\mcons\,m_f)
  & \mbox{Lemma \ref{lemma:monster_pure}} \\
{} = \apure_{\stream{M}}\,(\lambda f. f\,a) \appl \sigma_f
\end{array}
$$}
\end{proof}


To prove the final applicative law, we first need a few lemmas, and some new notation.
This law is much trickier than the previous ones, and requires many rewrite steps.

In the following we use repeatedly the types $A\times \stream{M}\,A$ and $M\,(A\times \stream{M}\,A)$, especially with $A$ being instantiated to different function types.
It is useful to use special notation for them:
$\pstream{A} = A\times \stream{M}\,A$, $\mstream{A} = M\,\pstream{A}$.
We use the notation $\pstr{a}$ for a generic element of $\pstream{A}$
and we allow ourselves to denote the first and second component of $\pstr{a}$ by $a$ and $\sigma_a$.
Elements of $\mstream{A}$ will be denoted by $m_a$.
We introduce notation for a {\em pure} value in the type $\pstream{A}$:
if $a:A$, we write $\ppair{a} = \langle a, \apure_{\stream{M}}\,a \rangle$.

We start with a little general lemma about {\em composition with compositions}.
The generic composition operator has type: $(\comp): (B\rightarrow C) \rightarrow (A\rightarrow B) \rightarrow A \rightarrow C$.
Suppose we want to compose it with a binary operator $(\oplus) : D\rightarrow (B\rightarrow C)$.
We use specialized notation for this higher composition, $\clift{\oplus}{A} = (\comp) \comp (\oplus) : D \rightarrow (A\rightarrow B) \rightarrow A \rightarrow C$.

We will in fact need to apply this {\em composition with compositions} operator twice: after producing $(\clift{\oplus}{A})$, we want in turn to compose it with the composition operator $(\comp): ((A\rightarrow B) \rightarrow (A\rightarrow C)) \rightarrow (X\rightarrow A\rightarrow B) \rightarrow X \rightarrow A \rightarrow C$ to produce the new operator $(\clift{\clift{\oplus}{A}}{X}): D\rightarrow (X\rightarrow A \rightarrow B) \rightarrow X \rightarrow A \rightarrow C$.

The following lemma states two properties of this higher composition operator.
It can be proved by just expanding definitions and simplifying.
\begin{lemma}\label{lemma:comp_comp}\label{lemma:comp_comp_comp}
$$
\begin{array}{l}
(\clift{\oplus}{A}) = \lambda d.\lambda f. \lambda a. d\oplus (f\,a) \\
(\clift{\clift{\oplus}{A}}{X}) =
\lambda d. \lambda h. \lambda x.\lambda a. d\oplus (h\,x\,a)
\end{array}
$$
\end{lemma}

With the help of Lemma \label{lemma:comp_comp} we can prove two technical equalities about the $\pappl$ operator. Their proofs are given in the Appendix.

\begin{lemma}\label{lemma:pappl_comp_appl}
Let $m_g:\mstream{B\rightarrow C}$, $m_f:\mstream{A\rightarrow B}$, $m_a:\mstream{A}$, then:
$$
m_g \alift{\pappl} (m_f \alift{\pappl} m_a)
 = \apure\, (\lambda \pstr{g}. \lambda \pstr{f}. \lambda \pstr{a}. \pstr{g} \pappl (\pstr{f}\pappl \pstr{a})) \appl m_g \appl m_f \appl m_a
$$
\end{lemma}

\begin{lemma}\label{lemma:ppair}
$$
\begin{array}{l}
\apure_M\,\ppair{\comp}\, \alift{\pappl}\, m_g\, \alift{\pappl}\, m_f\, \alift{\pappl}\, m_a \\
{}= \apure_M\,(\lambda \pstr{g}. \lambda \pstr{f}. \lambda \pstr{a}. \ppair{\comp}\, \pappl\, \pstr{g} \, \pappl\, \pstr{f} \, \pappl\, \pstr{a})\, \appl\, m_g\, \appl\, m_f\, \appl\, m_a 
\end{array}
$$
\end{lemma}

We're finally ready to complete the proof that monsters are applicative.
\begin{lemma}
Monsters satisfies the applicative composition law:
$$
\sigma_g \appl (\sigma_f \appl \sigma_a)
 = 
(\sigma_g \alift{\comp} \sigma_f) \appl \sigma_a
$$
\end{lemma}
\begin{proof}
We prove this by rewriting both the left and right-hand-side of the law
until we reduce them to a common high-level structure.
They will then differ only by a subterm inside the leftmost application of $\apure$ in this structure.
This difference is resolved by proving that the two argument of the $\apure$ terms are equivalent, making use of the coinductive hypothesis.

As usual we assume that all monsters are in canonical form: $\sigma_g = \mcons\,m_g$, $\sigma_f = \mcons\,m_f$, $\sigma_a = \mcons\,m_a$.

First we rewrite the left-hand-side of the composition law:
$$
\begin{array}{ll}
\sigma_g \appl (\sigma_f \appl \sigma_a)
 = (\mcons\,m_g) \appl ((\mcons\,m_f) \appl (\mcons\,m_a))\\
{}= \mcons\,(m_g \alift{\pappl} (m_f \alift{\pappl} m_a))
  &  \mbox{def of }\appl \\
{}= \mcons\,(
\apure_M\, (\lambda \pstr{g}. \lambda \pstr{f}. \lambda \pstr{a}. \pstr{g} \pappl (\pstr{f}\pappl \pstr{a})) \appl m_g \appl m_f \appl m_a
)
  & \mbox{Lemma \ref{lemma:pappl_comp_appl}}
\end{array}
$$

Next we rewrite the right-hand-side:
$$
\begin{array}{ll}
(\sigma_g \alift{\comp} \sigma_f) \appl \sigma_a\\
{}= \apure_{\stream{M}}\,(\comp) \appl \sigma_g \appl \sigma_f \appl \sigma_a
  & \mbox{def of }\alift{-}\\
{}= \mcons\, (\apure_M\,\pair{(\comp)}{\apure_{\stream{M}}\,(\comp)} \alift{\pappl} m_g \alift{\pappl} m_f \alift{\pappl} m_a)
  & \mbox{def of }\appl\\
{}= \mcons\, (\apure_M\,\ppair{\comp} \alift{\pappl} m_g \alift{\pappl} m_f \alift{\pappl} m_a)
  & \mbox{def of }\ppair{-}\\
{}= \mcons\,(
\apure_M\,(\lambda \pstr{g}. \lambda \pstr{f}. \lambda \pstr{a}. \ppair{\comp} \pappl \pstr{g}  \pappl \pstr{f}  \pappl \pstr{a}) \appl m_g \appl m_f \appl m_a)
  & \mbox{Lemma \ref{lemma:ppair}}
\end{array}
$$

To complete this proof, we need to show the following:
$$
\lambda \pstr{g}. \lambda \pstr{f}. \lambda \pstr{a}. \pstr{g} \pappl (\pstr{f}\pappl \pstr{a})
  = 
\lambda \pstr{g}. \lambda \pstr{f}. \lambda \pstr{a}. \ppair{\comp} \pappl \pstr{g}  \pappl \pstr{f}  \pappl \pstr{a}
$$

Let's assume the abstracted variables are in canonical form: $\pstr{g} = \pair{g}{\tau_g}$, $\pstr{f} = \pair{f}{\tau_f}$, $\pstr{a} = \pair{a}{\tau_a}$.
Unfolding the definition of $\pappl$ ans simplifying we get:
$$
\pstr{g}\, \pappl (\pstr{f} \pappl \pstr{a})
 = \pair{((\comp)\, g\, f)\, a}{\tau_g \appl (\tau_f \appl \tau_a)}
$$

Now notice that in the main term of the equality, this expression occurs under the $\mcons$ constructor and the $\apure_M$ operator, as the body of the function generating the $M$-subterms; it is a pair in which the second component matches the left-hand side of the main statement.
This is exactly the position were the application of the coinductive hypothesis is allowed, so we obtain:
$$
{} = \pair{(((\comp)\, g)\, f)\, a}{(\tau_g \alift{\comp} \tau_f) \appl \tau_a}
$$
which can be further simplified, by unfolding the definitions of $\alift{-}$ and $\pappl$:
$$
{} = \ppair{\comp} \pappl \pstr{g} \pappl \pstr{f} \pappl \pstr{a}
$$
This concludes the proof.
\end{proof}


\begin{theorem}\label{lemma:appl_laws}
If $M$ is an applicative functor, $\stream{M}$ is also an applicative functor.
\end{theorem}
