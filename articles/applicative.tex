\section{Monsters are Applicatives}\label{sec:applicative}

Applicative functors \cite{mcbride/paterson:2008}
extend the mapping operation by allowing function sequencing under the functor.
The Applicative class has two methods: $\apure$, that injects single values into the functor, and $\appl$, that applies functions under the functor:
$$
\begin{array}{l}
\apure : A \rightarrow M\,A\\
(\appl): M\,(A\rightarrow B) \rightarrow M\,A \rightarrow M\,B
\end{array}
$$
They must satisfy the four applicative laws given below (after we introduce some notation).

A typical use of applicative functors is to apply a function of many arguments to several applicative values.
If $g:A_0\rightarrow A_1 \rightarrow \cdots \rightarrow A_n \rightarrow B$ and $m_0:M\,A_0, m_1:M\,A_1, \ldots, m_n:M\,A_n$ , then:
$$
\apure\,g \appl m_0 \appl m_1 \appl \cdots \appl m_n : M\,B
$$

In particular, if $g$ is an infix binary operator $(\oplus) : A \rightarrow B \rightarrow C$, we can lift it to $M$-objects:
$$
m_a \alift{\oplus} m_b 
= \apure\,(\oplus) \appl m_a \appl m_b
$$

Here are the applicative functor laws for $M$, where
 $a:A$, $f:A\rightarrow B$,
$m_a:M\,A$, $m_f:M\,(A\rightarrow B)$, $m_g:M\,(B\rightarrow C)$.
$$
\begin{array}{l@{\qquad}l}
\apure\,\id \appl m_a = m_a
  & \mbox{Identity} \\
\apure\,f \appl \apure\,a = \apure\,(f\,a)
  & \mbox{Homomorphism} \\
m_f \appl \apure\,a = \apure\,(\lambda f. f\,a) \appl m_f
  & \mbox{Interchange} \\
m_g \appl (m_f \appl m_a) = (m_g \alift{\comp} m_f) \appl m_a
  & \mbox{Composition}
\end{array}
$$

A consequence of the Homomorphism and Composition Laws is that sequential application of functions can be reduced to a single application of the composition;
if $g:B\rightarrow D$ and $h:A_1\rightarrow A_2 \rightarrow C$, then:
$$
\begin{array}{l}
\apure\,g \appl (\apure\, f \appl m_a) = \apure\, (g\comp f) \appl m_a\\
\apure\,g \appl (\apure\, h \appl m_{a_1} \appl m_{a_2})
  = \apure\, (\lambda a.\lambda b. g\,(h\,a\,b)) \appl m_{a_1} \appl m_{a_2}
\end{array}
$$

Functoriality of $M$ follows from these laws, with functorial mapping defined as
$
M\,f\,m_a = \apure\,f \appl m_a.
$
The homomorphism law implies that
$
M\,f\,(\apure\,a) = \apure\,(f\,a).
$

The two previous observations validate the following characterization of the applicative lifting of a binary operator
 ($\pairing$ is the pairing operator, $\pairing\,a\,b = \pair{a}{b}$, and $\pairop{\oplus}$ operates on pairs, $\pairop{\oplus}\,\pair{a}{b} = a \oplus b$):
$$
\begin{array}{rl}
m_a \alift{\oplus} m_b 
& {} = \apure\,(\pairop{\oplus}) \appl (\apure\,\pairing\appl m_a\appl m_b) \\
& {}= M\,(\pairop{\oplus})\,(\apure\,\pairing\appl m_a\appl m_b)
\end{array}
$$

We will show that $\stream{M}$ is also applicative.
In order to define the methods, we need some auxiliary functions.
First of all, simplified versions of $\mcons$: appending either an $M$-action or a pure value in front of a monster.
The first works when $M$ is just a functor, the second when it is an applicative:
$$
\begin{array}{l}
(\fcons): M\,A \rightarrow \stream{M}\,A \rightarrow \stream{M}\,A\\
m \fcons \sigma = \mcons\, (M\,(\lambda a. \langle a, \sigma\rangle)\,m)
\end{array}\qquad
\begin{array}{l}
(\acons): A \rightarrow \stream{M}\,A \rightarrow \stream{M}\,A\\
a \acons \sigma = (\apure\, a) \fcons \sigma
\end{array}
$$

The $\apure$ method for monsters repeats the same element forever:
$$
\begin{array}{l}
\apure : A \rightarrow \stream{M}\,A\\
\apure\,a = a \acons \apure\,a
\end{array}
$$
To check that the recursive occurrence of $\apure\,a$ satisfies the guardedness condition we just unfold the definitions (we write the functor as a subscript to clarify which version of $\apure$ is used):
$$
\begin{array}{ll}
\apure_{\stream{M}}\,a 
& {} = a \acons \apure_{\stream{M}}\,a 
     = (\apure_M\, a) \fcons \apure_{\stream{M}}\,a \\
& {} = \mcons\, (M\,(\lambda a. \langle a, \apure_{\stream{M}}\,a \rangle)\, (\apure_M\, a))
\end{array}
$$
The recursive occurrence of $\apure_{\stream{M}}\,a$ is guarded by $\mcons$ and the functorial application of $M$.
The occurrence of $(\apure_M\, a)$ on the other hand. is not recursive and therefore unproblematic.

The homomorphism law for $M$ provides a further simplification.
\begin{lemma}\label{lemma:monster_pure} 
$$
\apure_{\stream{M}}\,a = \mcons\,(\apure_M\,\langle a, \apure_{\stream{M}}\,a\rangle)
$$
\end{lemma}

The previous discussion shows that the second arguments of $(\fcons)$ and $(\acons)$, when definitions are expanded, are guarded by the constructor $\mcons$.
Therefore, in future definitions and proofs, we allow ourselves to give corecursive definitions as that for $\apure\,a$ without justifying them by expansion.

In the following statements and proofs, we often need to write terms that combine the use of $\apure$ on $M$ and on $\stream{M}$.
This could be confusing, so we explicitly write the functors as subscript: $\apure_M$ and $\apure_{\stream{M}}$.
We also explicitly write the type of identity functions as a subscript.
We consistently use $\sigma$ with subscripts to denote monsters and $m$ with subscripts to denote $M$-actions.
We adopt the convention that $\apure$ binds stronger than any of the infix operators that we use, specifically $\appl$, $\alift{\comp}$ and $\alift{\pappl}$ (defined below).


We define the function application method by mapping straight function application on the heads and recursive calls on the tails through functorial and applicative lifting:

$$
\begin{array}{l}
(\appl) : \stream{M}\,(A\rightarrow B) \rightarrow \stream{M}\,A \rightarrow \stream{M}\,B\\
(\mcons\,m_f) \appl (\mcons\,m_a)
= \mcons\,(m_f \alift{\pappl} m_a)\\
\qquad \where\;
\langle f,\phi\rangle \pappl \langle a,\sigma\rangle 
= \langle f\,a, \phi \appl \sigma \rangle
\end{array}
$$

This definition recursively applies $\appl$ indirectly in the second components of the arguments of the $\pappl$ operator.
This is lifted to $\alift{\pappl}$, which distributes down through the components of the applicative values $m_f$ and $m_a$, and finally guarded by the constructor $\mcons$.
This guarantees the soundness of the definition according to the {\em guardedness-by-constructors} criterion.
(Formally, we can rewrite the definition, using the previous characterization of the applicative lifting of a binary operator, to reduce it to a syntactically guarded form.)

We aim to show that these definitions satisfy the applicative laws.
We assume that the laws hold for the base functor $M$ and we wish to prove them for the monster functor $\stream{M}$.

The new operator $\alift{\pappl}$ has a direct simplification on pure values, which will be very useful in the proofs of the laws.
\begin{lemma}\label{lemma:pappl}
If $f:A\rightarrow B$, $m_f:\stream{M}\,(A\rightarrow B)$, $a:A$, $m_a:\stream{M}\,A$, then:
$$
\apure_M\,\langle f, m_f\rangle \alift{\pappl} \apure_M\,\langle a, m_a\rangle = \apure_M \langle f\,a, m_f \appl m_a \rangle
$$
\end{lemma}
\begin{proof}
By definition of ${}\alift{-}{}$ and the homomorphism law for $M$.
\end{proof}

\begin{lemma}
Monsters satisfy the applicative identity law:
$$
\apure_{\stream{M}}\,\id_A \appl \sigma_a = \sigma_a
$$
\end{lemma}
\begin{proof}
Assume that $\sigma_a$ has the canonical form:
$\sigma_a = \mcons\,m$ where $m:M\,(A\times \stream{M}A).$
Most of the proof is by straightforward equational reasoning, unfolding definitions and using the applicative laws for $M$.

The only unusual step is the application of the {\em coinduction hypothesis}.
Recall that this means that we can assume that the statement to prove is already true, as long as it is invoked only on direct arguments of the monster constructor.
Specifically, we can invoke it on the recursive application $\phi \appl \sigma$ in the definition of $\appl$, since that occurrence is guarded.

By expanding definitions and using the interchange and homomorphism laws for $M$ we obtain:
$$
\apure_{\stream{M}}\,\id_A \appl \sigma_a \\
= \mcons\,(\apure_M\,(\lambda \langle a,\sigma_a\rangle. \langle \id_A\,a, \apure_{\stream{M}}\,\id_A \appl \sigma_a\rangle) \appl m)
$$
The recursive occurrence $\apure_{\stream{M}}\,\id_A \appl \sigma_a$ is guarded, therefore we can apply the coinductive hypothesis to it:
$$
\cdots = \mcons\,(\apure_M\,(\lambda \langle a,\sigma_a\rangle. \langle a, \sigma_a\rangle) \appl m)
$$
this trivially reduces to $(\mcons\,m) = \sigma_a$, as desired.
\hide{
$$
\begin{array}{ll}
\apure_{\stream{M}}\,\id_A \appl \sigma_a \\
{}= (\id_A \acons (\apure_{\stream{M}}\,\id_A)) \appl \sigma_a
  & \mbox{definition of }\apure \\
{}= ((\apure_M\,\id_A) \fcons (\apure_{\stream{M}}\,\id_A)) \appl \sigma_a
  & \mbox{definition of }\acons \\
{}= (\mcons\,(M\,(\lambda f. \langle f, \apure_{\stream{M}}\,\id_A\rangle)\,(\apure_M\,\id_A))) \appl \sigma_a
  & \mbox{definition of }\fcons \\
{}= (\mcons\,(\apure_M\,\langle \id_A, \apure_{\stream{M}}\,\id_A \rangle)) \appl \sigma_a
  & \mbox{interchange law for }M \\
{}= (\mcons\,(\apure_M\,\langle \id_A, \apure_{\stream{M}}\,\id_A\rangle)) \appl (\mcons\,m)
  & \mbox{canonical form of }\sigma_a\\
{}= \mcons\,(\apure_M\,\langle \id_A, \apure_{\stream{M}}\,\id_A\rangle)) \alift{\pappl}  m)
  & \mbox{definition of }\appl \\
{}= \mcons\,(\apure_{M}\,(\pappl) \appl \apure_M\,\langle \id_A, \apure_{\stream{M}}\,\id_A\rangle \appl  m)
  & \mbox{definition of }\alift{-} \\
{}= \mcons\,(\apure_M\,((\pappl)\,\langle \id_A, \apure_{\stream{M}}\,\id_A\rangle) \appl  m)
  & \mbox{homomorphism law for }M\\
{}= \mcons\,(\apure_M\,(\lambda \langle a,\sigma_a\rangle. \langle \id_A, \apure_{\stream{M}}\,\id_A\rangle \pappl \langle a,\sigma_a\rangle) \appl m)
  & \mbox{expansion of the section}\\
{}= \mcons\,(\apure_M\,(\lambda \langle a,\sigma_a\rangle. \langle \id_A\,a, \apure_{\stream{M}}\,\id_A \appl \sigma_a\rangle) \appl m)
  & \mbox{definition of }\pappl\\
{}= \mcons\,(\apure_M\,(\lambda \langle a,\sigma_a\rangle. \langle a, \sigma_a\rangle) \appl m)
  & \mbox{coinduction hypothesis}\\
{}= \mcons\,(\apure_M\,\id_{A\times\stream{M}A} \appl m)
  & \mbox{trivial}\\
{}= \mcons\,m = \sigma_a
  & \mbox{identity law for }M
\end{array}
$$

In the step that makes use of the coinduction hypothesis, we circularly use the lemma's statement that $\apure_{\stream{M}}\,\id_A \appl \sigma_a = \sigma_a$.
The right-hand side occurs under an application of the constructor $\mcons$, inside an application of a pure value. 
This structural positioning of the term ensure that the application of the coinductive hypothesis is sound.}
\end{proof}

\begin{lemma}
Monsters satisfy the applicative homomorphism law:

$$
\apure_{\stream{M}}\,f \appl \apure_{\stream{M}}\,a = \apure\,(f\,a)
$$

\end{lemma}
\begin{proof}

$$
\begin{array}{ll}
\apure_{\stream{M}}\,f \appl \apure_{\stream{M}}\,a\\
{}= (\mcons\,(\apure_M\,\langle f, \apure_{\stream{M}}\,f\rangle)) \appl
    (\mcons\,(\apure_M\,\langle a, \apure_{\stream{M}}\,a\rangle))
  & \mbox{Lemma \ref{lemma:monster_pure}}\\
{}= \mcons\,(\apure_M\,\langle f, \apure_{\stream{M}}\,f\rangle \alift{\pappl}
             \apure_M\,\langle a, \apure_{\stream{M}}\,a\rangle)
  & \mbox{definition of }\appl\\
{}= \mcons\,(\apure_M\,\langle f\, a, \apure_{\stream{M}}\,f \appl \apure_{\stream{M}}\,a \rangle))
  & \mbox{Lemma }\ref{lemma:pappl}\\
{}= \mcons\,(\apure_M\,\langle f\,a, \apure_{\stream{M}}\,(f\,a)\rangle)
  & \mbox{coinduction hypothesis}\\
{}= \apure_{\stream{M}}\,(f\,a)
  & \mbox{lemma }\ref{lemma:monster_pure}
\end{array}
$$
\end{proof}


% Proof of interchange law with M applicative
The proofs of the following technical lemmas are included in the Appendix.
\vcomm{maybe just say that they are easy equational proofs, no Appendix}

\begin{lemma}\label{lemma:pure_lift}
If $a:A$, $b:B$ and $(\oplus) : A \rightarrow B \rightarrow C$, then:
$$
\apure_M\, a \alift{\oplus} \apure_M\, b = \apure_M\, (a \oplus b)
$$
\end{lemma} 

\begin{lemma}\label{lemma:applicative_flip}
If $f : A \rightarrow B \rightarrow C$, $m_a : M\, A$ and $b : B$, then:
$$
\apure_M\, f \appl m_a \appl \apure_M\, b = \apure_M\, (\lambda a . f\, a\, b) \appl m_a
$$
\end{lemma}

This lemma is extremely useful in the following proofs of the last two applicative laws.

\begin{lemma}
Monsters satisfy the applicative interchange law.
 If $\sigma_f: \stream{M}(A\rightarrow B)$ and $a:A$, then:

$$
\sigma_f \appl \apure_{\stream{M}}\,a = \apure_{\stream{M}}\,(\lambda f. f\,a) \appl \sigma_f
$$

\end{lemma}
\begin{proof}
Assume that $\sigma_f = \mcons\,m_f$ for some $m_f:M\,((A\rightarrow B)\times \stream{M}\,(A\rightarrow B))$.

$$
\begin{array}{ll}
\sigma_f \appl \apure_{\stream{M}}\,a = (\mcons\,m_f) \appl \apure_{\stream{M}}\,a \\
{}= (\mcons\,m_f) \appl (\mcons\,(\apure_M\,\langle a, \apure_{\stream{M}}\,a\rangle))
  & \mbox{Lemma \ref{lemma:monster_pure}}\\
{}= \mcons\,(m_f \alift{\pappl} \apure_M\,\langle a, \apure_{\stream{M}}\,a\rangle)
  & \mbox{definition of }\appl\\
{}= \mcons\,(\apure_M\,(\pappl) \appl m_f \appl \apure_M\,\langle a, \apure_{\stream{M}}\,a\rangle)
  & \mbox{definition of }\alift{-}\\
{}= \mcons \, (\apure_M\,(\lambda \pair{f}{\phi} . \pair{f}{\phi} \pappl \pair{a}{\apure_{\stream{M}}\,a}) \appl m_f)
  & \mbox{Lemma \ref{lemma:applicative_flip}}\\
{}= \mcons\,(\apure_M\,(\lambda \pair{f}{\phi} . \pair{f a}{\phi \appl \apure_{\stream{M}}\,a}) \appl m_f)
  & \mbox{definition of } \pappl \\
{}= \mcons\,(\apure_M\,(\lambda \pair{f}{\phi} . \pair{f a}{\apure_{\stream{M}}\,(\lambda f . f\, a) \appl \phi}) \appl m_f)
  & \mbox{coinduction hypothesis} \\
{}= \mcons\,(\apure_M\,(\lambda \pair{f}{\phi}.
    \pair{\lambda f . f\, a}{\apure_{\stream{M}}\,(\lambda f . f\, a))}
    \pappl \pair{f}{\phi}
    ) \appl m_f)
  & \mbox{definition of } \pappl \\
{}= \mcons\,(\apure_M\,(\pappl) \appl \apure_M\,\langle \lambda f. f\,a, \apure_{\stream{M}}\,(\lambda f. f\,a)  \rangle \appl m_f)
  & \mbox{homomorphism law for }M \\
{}= \mcons\,(\apure_M\,\langle \lambda f. f\,a, \apure_{\stream{M}}\,(\lambda f. f\,a)  \rangle \alift{\pappl} m_f)
  & \mbox{definition of }\alift{-}\\
{}= (\mcons\,(\apure_M\,\langle \lambda f. f\,a, \apure_{\stream{M}}\,(\lambda f. f\,a)  \rangle)) \appl (\mcons\,m_f)
  & \mbox{definition of }\appl \\
{}= \apure_{\stream{M}}\,(\lambda f. f\,a) \appl (\mcons\,m_f)
  & \mbox{Lemma \ref{lemma:monster_pure}} \\
{} = \apure_{\stream{M}}\,(\lambda f. f\,a) \appl \sigma_f
\end{array}
$$
\end{proof}


To prove the final applicative law, we first need a few lemmas, and some new notation.
This law is much trickier than the previous ones, and requires many rewrite steps.

In the following we use repeatedly the types $A\times \stream{M}\,A$ and $M\,(A\times \stream{M}\,A)$, especially with $A$ being instantiated to different function types.
It is useful to use special notation for them:
$\pstream{A} = A\times \stream{M}\,A$, $\mstream{A} = M\,\pstream{A}$.
We use the notation $\pstr{a}$ for a generic element of $\pstream{A}$
and we allow ourselves to denote the first and second component of $\pstr{a}$ by $a$ and $\sigma_a$.
Elements of $\mstream{A}$ will be denoted by $m_a$.
We introduce notation for a {\em pure} value in the type $\pstream{A}$:
if $a:A$, we write $\ppair{a} = \langle a, \apure_{\stream{M}}\,a \rangle$.



We start with a little general lemma about {\em composition with compositions}.
The generic composition operator has type: $(\comp): (B\rightarrow C) \rightarrow (A\rightarrow B) \rightarrow A \rightarrow C$.
Suppose we want to compose it with a binary operator $(\oplus) : D\rightarrow (B\rightarrow C)$.
What would this higher composition, $(\comp) \comp (\oplus) : D \rightarrow (A\rightarrow B) \rightarrow A \rightarrow C$ be?
We will use the notation $\clift{\oplus}{A}$ for it.
\begin{lemma}\label{lemma:comp_comp}

$$
(\clift{\oplus}{A}) = \lambda d.\lambda f. \lambda a. d\oplus (f\,a)
$$

\end{lemma}
\begin{proof}
Just expand the definition of the two composition operators.
\end{proof}

We will in fact need to apply this {\em composition with compositions} operator twice: after producing $(\clift{\oplus}{A})$, we want in turn to compose it with the composition operator $(\comp): ((A\rightarrow B) \rightarrow (A\rightarrow C)) \rightarrow (X\rightarrow A\rightarrow B) \rightarrow X \rightarrow A \rightarrow C$ to produce the new operator $(\clift{\clift{\oplus}{A}}{X}): D\rightarrow (X\rightarrow A \rightarrow B) \rightarrow X \rightarrow A \rightarrow C$.
\begin{lemma}\label{lemma:comp_comp_comp}

$$
(\clift{\clift{\oplus}{A}}{X}) =
\lambda d. \lambda h. \lambda x.\lambda a. d\oplus (h\,x\,a)
$$

\end{lemma}
\begin{proof}
Apply Lemma \ref{lemma:comp_comp} twice and simplify.
\end{proof}

\begin{lemma}\label{lemma:pappl_comp_appl}
Let $m_g:\mstream{B\rightarrow C}$, $m_f:\mstream{A\rightarrow B}$, $m_a:\mstream{A}$, then:

$$
m_g \alift{\pappl} (m_f \alift{\pappl} m_a)
 = \apure\, (\lambda \pstr{g}. \lambda \pstr{f}. \lambda \pstr{a}. \pstr{g} \pappl (\pstr{f}\pappl \pstr{a})) \appl m_g \appl m_f \appl m_a
$$

\end{lemma}


\begin{lemma}\label{lemma:ppair}

$$
\apure_M\,\ppair{\comp}\, \alift{\pappl}\, m_g\, \alift{\pappl}\, m_f\, \alift{\pappl}\, m_a
= \apure_M\,(\lambda \pstr{g}. \lambda \pstr{f}. \lambda \pstr{a}. \ppair{\comp}\, \pappl\, \pstr{g} \, \pappl\, \pstr{f} \, \pappl\, \pstr{a})\, \appl\, m_g\, \appl\, m_f\, \appl\, m_a 
$$

\end{lemma}

\begin{lemma}
Monsters satisfies the applicative composition law:

$$
\sigma_g \appl (\sigma_f \appl \sigma_a)
 = 
(\sigma_g \alift{\comp} \sigma_f) \appl \sigma_a
$$
\end{lemma}
\begin{proof}
We prove this by rewriting both the left and right-hand-side of the law
until we reduce them to a common high-level structure.
They will then differ only by a subterm inside the leftmost application of $\apure$ in this structure.
This difference is resolved by proving that the two argument of the $\apure$ terms are equivalent, making use of the coinductive hypothesis.

As usual we assume that all monsters are in canonical form: $\sigma_g = \mcons\,m_g$, $\sigma_f = \mcons\,m_f$, $\sigma_a = \mcons\,m_a$.

First we rewrite the left-hand-side of the composition law. 

$$
\begin{array}{l}
\sigma_g \appl (\sigma_f \appl \sigma_a)
 = (\mcons\,m_g) \appl ((\mcons\,m_f) \appl (\mcons\,m_a))\\
{}= \mcons\,(m_g \alift{\pappl} (m_f \alift{\pappl} m_a))\\
  \qquad  \mbox{definition of}\appl\mbox{for monsters} \\
{}= \mcons\,(
\apure_M\, (\lambda \pstr{g}. \lambda \pstr{f}. \lambda \pstr{a}. \pstr{g} \pappl (\pstr{f}\pappl \pstr{a})) \appl m_g \appl m_f \appl m_a
)\\
  \qquad \mbox{Lemma \ref{lemma:pappl_comp_appl}}
\end{array}
$$

Next we rewrite the right-hand-side.

$$
\begin{array}{l}
(\sigma_g \alift{\comp} \sigma_f) \appl \sigma_a\\
{}= \apure_{\stream{M}}\,(\comp) \appl \sigma_g \appl \sigma_f \appl \sigma_a \\
  \qquad \mbox{definition of }\alift{-}\\
{}= \mcons\, (\apure_M\,\pair{(\comp)}{\apure_{\stream{M}}\,(\comp)} \alift{\pappl} m_g \alift{\pappl} m_f \alift{\pappl} m_a)\\
  \qquad \mbox{definition of}\appl\mbox{for monsters}\\
{}= \mcons\, (\apure_M\,\ppair{\comp} \alift{\pappl} m_g \alift{\pappl} m_f \alift{\pappl} m_a)\\
  \qquad \mbox{definition of }\ppair{-}\\
{}= \mcons\,(
\apure_M\,(\lambda \pstr{g}. \lambda \pstr{f}. \lambda \pstr{a}. \ppair{\comp} \pappl \pstr{g}  \pappl \pstr{f}  \pappl \pstr{a}) \appl m_g \appl m_f \appl m_a)\\
  \qquad \mbox{Lemma \ref{lemma:ppair}}
\end{array}
$$

To complete this proof, we need to show the following:

$$
\lambda \pstr{g}. \lambda \pstr{f}. \lambda \pstr{a}. \pstr{g} \pappl (\pstr{f}\pappl \pstr{a})
  = 
\lambda \pstr{g}. \lambda \pstr{f}. \lambda \pstr{a}. \ppair{\comp} \pappl \pstr{g}  \pappl \pstr{f}  \pappl \pstr{a}
$$

Let's assume the abstracted variables are in canonical form: $\pstr{g} = \pair{g}{\tau_g}$, $\pstr{f} = \pair{f}{\tau_f}$, $\pstr{a} = \pair{a}{\tau_a}$.

We use the coinduction hypothesis to prove the equality.
This is justified because the equality itself is embedded in an application of the constructor $\mcons$: in this context, $\tau_g$, $\tau_f$ and $\tau_a$ are guaranteed to be sub-streams of $\sigma_g$, $\sigma_f$ and $\sigma_a$ respectively, so the use of the coinductive hypothesis is sound.

$$
\begin{array}{ll}
\pstr{g}\, \pappl (\pstr{f} \pappl \pstr{a})
 = \pair{g}{\tau_g}\, \pappl (\pair{f}{\tau_f} \pappl \pair{a}{\tau_a}) \\
{}= \pair{g}{\tau_g}\, \pappl \pair{f\, a}{\tau_f \appl \tau_a}
& \mbox{definition of }\pappl \\
{}= \pair{g\, (f\, a)}{\tau_g \appl (\tau_f \appl \tau_a)}
& \mbox{definition of }\pappl \\
{}= \pair{(g \comp f)\, a)}{\tau_g \appl (\tau_f \appl \tau_a)}
& \mbox{definition of }\comp \\
{}= \pair{((\comp)\, g\, f)\, a}{\tau_g \appl (\tau_f \appl \tau_a)}
& \mbox{trivial} \\
{}= \pair{(((\comp)\, g)\, f)\, a}{(\tau_g \alift{\comp} \tau_f) \appl \tau_a}
& \mbox{coinduction hypothesis} \\
{}= \pair{(((\comp)\, g)\, f)\, a}{\apure_{\stream{M}}\, (\comp) \appl \tau_g \appl \tau_f \appl \tau_a}
& \mbox{definition of }\alift{-} \\
{}= \pair{((\comp)\, g)\, f}{\apure_{\stream{M}}\, (\comp) \appl \tau_g \appl \tau_f} \pappl  \pair{a}{\tau_a}
& \mbox{definition of }\pappl \\
{}= \pair{(\comp)\, g}{\apure_{\stream{M}}\, (\comp) \appl \tau_g} \pappl \pair{f}{\tau_f} \pappl \pair{a}{\tau_a}
& \mbox{definition of }\pappl \\
{}= \pair{(\comp)}{\apure_{\stream{M}}\,(\comp)} \pappl \pair{g}{\tau_g} \pappl \pair{f}{\tau_f} \pappl \pair{a}{\tau_a}
& \mbox{definition of }\pappl \\
{}= \ppair{\comp} \pappl \pstr{g} \pappl \pstr{f} \pappl \pstr{a}
\end{array}
$$
\end{proof}


\begin{theorem}\label{lemma:appl_laws}
If $M$ is an applicative functor, $\stream{M}$ is also an applicative functor.
\end{theorem}
