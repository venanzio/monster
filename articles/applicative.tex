\section{Monsters are Applicatives}

Applicative functors \cite{mcbride/paterson:2008}
extend the mapping operation by allowing function sequencing under the functor.
The Applicative class has two methods: $\apure$, that injects single values into the functor, and $\appl$, that applies functions under the functor.

We assume that the type operator $M$ is an applicative functor, that is, it has methods:
$$
\begin{array}{l}
\apure : A \rightarrow M\,A\\
(\appl): M\,(A\rightarrow B) \rightarrow M\,A \rightarrow M\,B
\end{array}
$$
satisfying the four equational laws regulating the interaction of sequencing and pure values and requiring associativity of application.

For the base functor $M$, the laws take the following form, where
 $a:A$, $f:A\rightarrow B$,
$m_a:M\,A$, $m_f:M\,(A\rightarrow B)$, $m_g:M\,(B\rightarrow C)$.
$$
\begin{array}{l@{\qquad}l}
(\apure\,\id) \appl m_a = m_a
  & \mbox{Identity} \\
(\apure\,f) \appl (\apure\,a) = \apure\,(f\,a)
  & \mbox{Homomorphism} \\
m_f \appl (\apure\,a) = (\apure\,(\lambda f. f\,a)) \appl m_f
  & \mbox{Interchange} \\
m_g \appl (m_f \appl m_a) = (m_g \alift{\comp} m_f) \appl m_a
  & \mbox{Composition}
\end{array}
$$

Functoriality of $M$ follows from these laws, with functorial mapping defined as
$
M\,f\,m_a = (\apure\,f) \appl m_a.
$
The interchange law implies that
$
M\,f\,(\apure\,a) = \apure\,(f\,a).
$

A typical use of applicative functors is to apply a function of many arguments to several applicative values.
If $g:A_0\rightarrow A_1 \rightarrow \cdots \rightarrow A_n \rightarrow B$ and $m_0:M\,A_0, m_1:M\,A_1, \ldots, m_n:M\,A_n$ , then:
$$
(\apure\,g) \appl m_0 \appl m_1 \appl \cdots \appl m_n : M\,B
$$

In particular, if $g$ is an infix binary operator $(\oplus) : A \rightarrow B \rightarrow C$, then we use the notation:
$$
m_a \alift{\oplus} m_b = (\apure\,(\oplus)) \appl m_a \appl m_b
$$

We will show that $\stream{M}$ is also applicative.
In order to define the methods, we need some auxiliary functions on applicative monsters.
First of all, a simplified version of $\mcons$ that appends a single value in front of a monster.
This in turn uses a similar operator for functors, which appends an $M$-action to the front of a monster
$$
\begin{array}{l}
(\fcons): M\,A \rightarrow \stream{M}\,A \rightarrow \stream{M}\,A\\
m \fcons \sigma = \mcons\, (M\,(\lambda a. \langle a, \sigma\rangle)\,m)\\
\,\\
(\acons): A \rightarrow \stream{M}\,A \rightarrow \stream{M}\,A\\
a \acons \sigma = (\apure\, a) \fcons \sigma
\end{array}
$$

The $\apure$ method for monsters then consists in repeating the same element forever:
$$
\begin{array}{l}
\apure : A \rightarrow \stream{M}\,A\\
\apure\,a = a \acons \apure\,a
\end{array}
$$

Using the applicative laws for $M$, we can give a simplified characterization of pure monsters.
The term we use combine the use of $\apure$ on $M$ and on $\stream{M}$.
This could be confusing, so we explicitely write the functor as subscript.
\begin{lemma}\label{lemma:monster_pure}
$$
\apure_{\stream{M}}\,a = \mcons\,(\apure_M\,\langle a, \apure_{\stream{M}}\,a\rangle)
$$
\end{lemma}
\begin{proof}
By unfolding definitions and using the identity law for the applicative functor $M$:
$$
\begin{array}{ll}
\apure_{\stream{M}}\,a \\
{}= a \acons \apure_{\stream{M}}\,a
  & \mbox{by definition of }\apure_{\stream{M}} \\
{}= (\apure_M\,a) \fcons (\apure_{\stream{M}}\,a)
  & \mbox{by definition of }\acons\\
{}=  \mcons\, (M\,(\lambda a. \langle a, \apure_{\stream{M}}\,a\rangle)\,(\apure_M\,a))
  & \mbox{by definition of }\fcons\\
{}= \mcons\, ((\apure_M\,(\lambda a. \langle a, \apure_{\stream{M}}\,a\rangle)) \appl (\apure_M\,a))
  & \mbox{by functoriality of applicatives}\\
{}= \mcons\, (\apure_M\,((\lambda a. \langle a, \apure_{\stream{M}}\,a\rangle)\,a))
  & \mbox{by the homomorphism law for }M\\
{}= \mcons\, (\apure_M\,\langle a, \apure_{\stream{M}}\,a\rangle)
  & \mbox{by function application}
\end{array}
$$
\end{proof}

We define the function application method by mapping straight function application on the heads and recursive calls on the tails through functorial and applicative lifting:
$$
\begin{array}{l}
(\appl) : \stream{M}\,(A\rightarrow B) \rightarrow \stream{M}\,A \rightarrow \stream{M}\,B\\
(\mcons\,m_f) \appl (\mcons\,m_a)
= \mcons\,(m_f \alift{\pappl} m_a)\\
\qquad \where\;
\langle f,\phi\rangle \pappl \langle a,\sigma\rangle 
= \langle f\,a, \phi \appl \sigma \rangle
\end{array}
$$

This definition recursively applies $\appl$ indirectly in the second components of the arguments of the $\pappl$ operator.
This is lifted to $\alift{\pappl}$, which distributes down through the components of the applicative values $m_f$ and $m_a$, and finally guarded by the constructor $\mcons$.
This guarantees the soundness of the definition according to the {\em guardedness by constructors} criterion.

We aim to show that these definitions satisfy the applicative laws.
We assume that the laws are satisfied by the base functor and we aim to prove them for the monster functor.

\vcomm{I leave this year with the conjecture: to be placed at the end as a Theorem when we have the proofs.}
Preliminary investigation and analysis of specific instances suggest that this is the case for monsters.
A full proof is one of the goals of future work.
\begin{conjecture}\label{lemma:appl_laws}
If $M$ is an applicative functor, $\stream{M}$ is also an applicative functor.
That is, the following laws are satisfied, for every $a:A$, $f:A\rightarrow B$, $\sigma_a:\stream{M}\,A$, $\sigma_f : \stream{M}\,(A\rightarrow B)$, $\sigma_g: \stream{M}\,(B\rightarrow C)$:
$$
\begin{array}{l}
(\apure\,\id) \appl \sigma_a = \sigma_a \\
(\apure\,f) \appl (\apure\,a) = \apure\,(f\,a) \\
\sigma_f \appl (\apure\,a) = (\apure\,(\lambda f. f\,a)) \appl \sigma_f \\
\sigma_g \appl (\sigma_f \appl \sigma_a) = (\sigma_g \alift{\comp} \sigma_f) \appl \sigma_a
\end{array}
$$
\end{conjecture}

The new operator $\alift{\pappl}$ has a direct simplification on pure values, which will be very useful in the proofs of the laws.
\begin{lemma}\label{lemma:pappl}
If $f:A\rightarrow B$, $m_f:\stream{M}\,(A\rightarrow B)$, $a:A$, $m_a:\stream{M}\,A$, then:
$$
(\apure_M\,\langle f, m_f\rangle) \alift{\pappl} (\apure_M\,\langle a, m_a\rangle) = \apure_M \langle f\,a, m_f \appl m_a \rangle
$$
\end{lemma}
\begin{proof}
$$
\begin{array}{ll}
(\apure_M\,\langle f, m_f\rangle) \alift{\pappl} (\apure_M\,\langle a, m_a\rangle) \\
{}= (\apure_M\,(\pappl)) \appl (\apure_M\,\langle f, m_f\rangle) \appl (\apure_M\,\langle a, m_a\rangle)
  & \mbox{by definition of }\alift{-}\\
{}= \apure_M\,(\langle f, m_f\rangle \pappl \langle a, m_a\rangle)
  & \mbox{by the homomorphism law for }M\\
{}= \apure_M\,\langle f\,a, m_f \appl m_a \rangle
  & \mbox{by definition of }\pappl
\end{array}
$$
\end{proof}


In the proofs, we need to avoid confusion between the applicative operations for $M$ and those for $\stream{M}$.
We assume that the laws are valid for $M$ and we want to prove them for $\stream{M}$.
In the formulas, the two sets of operations will occur in the same terms, potentially leading to confusion.
It is clear from the type of the arguments which version is intended, but it may be challenging to keep track of the types.
Therefore we will use a slightly heavier but clearer notation: we use $M$ as subscript for $\apure$ when the $M$ version is intended, $\stream{M}$ when the monster version is intended; we consistently use $\sigma$ with subscripts to denote monsters and $m$ with subscripts to denote $M$-actions; we explicitely write the argument type of identity functions as subscripts.
We won't distinguish the occurrences of $\appl$ for $M$ and $\stream{M}$ with subscripts, but they should be clear given the previous notational conventions.

\begin{lemma}
Monsters satisfy the applicative identity law:
$$
(\apure_{\stream{M}}\,\id_A) \appl \sigma_a = \sigma_a
$$
We will assume that the $\sigma_a$ has the canonical form:
$\sigma_a = \mcons\,m$ where $m:M\,(A\times \stream{M}A).$
\end{lemma}
\begin{proof}
Most of the proof is by straightforward equational reasoning, unfolding definitions and using the applicative laws for $M$.

The only unusual step is the application of the {\em coinduction hypothesis}.
Recall that this means that we can assume that the statement to prove is already true, as long as it is invoked directly on direct arguments of the monster constructor.
$$
\begin{array}{ll}
(\apure_{\stream{M}}\,\id_A) \appl \sigma_a \\
{}= (\id_A \acons (\apure_{\stream{M}}\,\id_A)) \appl \sigma_a
  & \mbox{by definition of }\apure \\
{}= ((\apure_M\,\id_A) \fcons (\apure_{\stream{M}}\,\id_A)) \appl \sigma_a
  & \mbox{by definition of }\acons \\
{}= (\mcons\,(M\,(\lambda f. \langle f, (\apure_{\stream{M}}\,\id_A)\rangle)\,(\apure_M\,\id_A))) \appl \sigma_a
  & \mbox{by definition of }\fcons \\
{}= (\mcons\,(\apure_M\,\langle \id_A, (\apure_{\stream{M}}\,\id_A)\rangle)) \appl \sigma_a
  & \mbox{by the interchange law} \\
{}= (\mcons\,(\apure_M\,\langle \id_A, (\apure_{\stream{M}}\,\id_A)\rangle)) \appl (\mcons\,m)
  & \mbox{canonical form of }\sigma_a\\
{}= \mcons\,(\apure_M\,\langle \id_A, (\apure_{\stream{M}}\,\id_A)\rangle)) \alift{\pappl}  m)
  & \mbox{by definition of }\appl \\
{}= \mcons\,((\apure_{M}\,\pappl) \appl (\apure_M\,\langle \id_A, (\apure_{\stream{M}}\,\id_A)\rangle) \appl  m)
  & \mbox{by definition of }\alift{-} \\
{}= \mcons\,(\apure_M\,((\pappl)\,\langle \id_A, (\apure_{\stream{M}}\,\id_A)\rangle) \appl  m)
  & \mbox{by the homomorphism law}\\
{}= \mcons\,(\apure_M\,(\lambda \langle a,\sigma_a\rangle. \langle \id_A, (\apure_{\stream{M}}\,\id_A)\rangle \pappl \langle a,\sigma_a\rangle) \appl m)
  & \mbox{expansion of the section}\\
{}= \mcons\,(\apure_M\,(\lambda \langle a,\sigma_a\rangle. \langle \id_A\,a, (\apure_{\stream{M}}\,\id_A) \appl \sigma_a\rangle) \appl m)
  & \mbox{definition of }\pappl\\
{}= \mcons\,(\apure_M\,(\lambda \langle a,\sigma_a\rangle. \langle a, \sigma_a\rangle) \appl m)
  & \mbox{\bf by coinduction hypothesis}\\
{}= \mcons\,(\apure_M\,\id_{A\times\stream{M}A} \appl m)
  & \mbox{trivial}\\
{}= \mcons\,m = \sigma_a
  & \mbox{by the identity law for }M
\end{array}
$$
In the step that makes use of the coinduction hypothesis, we circularly use the lemma's statement that $(\apure_{\stream{M}}\,\id_A) \appl \sigma_a = \sigma_a$.
The right-hand side occurs under an application of the constructor $\mcons$, inside an application of a pure value. 
This stuctural positioning of the term ensure that the application of the coinductive hypothesis is sound.

\vcomm{This is intuitively OK, but it may be worth exploring it further and making it more rigorous by studying how application of pure functions generate the structure of the result.}
\end{proof}

\begin{lemma}
Monsters satisfy the applicative homomorphism law:
$$
(\apure\,f) \appl (\apure\,a) = \apure\,(f\,a)
$$
\end{lemma}
\begin{proof}
$$
\begin{array}{ll}
(\apure\,f) \appl (\apure\,a)\\
{}= (\mcons\,(\apure_M\,\langle f, \apure_{\stream{M}}\,f\rangle)) \appl
    (\mcons\,(\apure_M\,\langle a, \apure_{\stream{M}}\,a\rangle))
  & \mbox{by Lemma \ref{lemma:monster_pure}}\\
{}= \mcons\,((\apure_M\,\langle f, \apure_{\stream{M}}\,f\rangle) \alift{\pappl}
             (\apure_M\,\langle a, \apure_{\stream{M}}\,a\rangle))
  & \mbox{by definition of }\appl\\
{}= \mcons\,(\apure_M\,(\langle f, \apure_{\stream{M}}\,f\rangle \appl \langle a, \apure_{\stream{M}}\,a\rangle))
  & \mbox{by Lemma }\ref{lemma:pappl}\\
{}= \mcons\,(\apure_M\,\langle f\,a, \apure_{\stream{M}}\,(f\,a)\rangle)
  & \mbox{by coinduction hypothesis}\\
{}= \apure_{\stream{M}}\,(f\,a)
  & \mbox{by lemma }\ref{lemma:monster_pure}
\end{array}
$$
\end{proof}




% Proof of interchange law with M applicative

\begin{lemma}\label{lemma:pure_lift}
For an applicative functor $M$, with $a:A$, $b:B$ and $(\oplus) : A \rightarrow B \rightarrow C$:
$$
(\apure_M\, a) \alift{\oplus} (\apure_M\, b) = \apure_M\, (a \oplus b)
$$
\end{lemma}
\begin{proof}
$$
\begin{array}{ll}
(\apure_M\, a) \alift{\oplus} (\apure_M\, b) \\
{}= \apure_M\, (\oplus) \appl (\apure_M\, a) \appl (\apure_M\, b)
  & \mbox{by definition of }\alift{-}\\
{}= \apure_M\, (a\, \oplus) \appl (\apure_M\, b)
  & \mbox{by homomorphism law of }M\\
{}= \apure_M\, (a \oplus b)
  & \mbox{by homomorphism law of }M\\
\end{array}
$$
\end{proof}

\begin{lemma}\label{lemma:applicative_flip}
Assuming $M$ is an applicative, with $f : A \rightarrow B \rightarrow C$, $m_a : M\, A$ and $b : B$:
$$
(\apure_M\, f) \appl m_a \appl (\apure_M\, b) = (\apure_M\, (\lambda a . f\, a\, b)) \appl m_a
$$
\end{lemma}
\begin{proof}
Since the operator $\appl$ is left-associative, the left hand side of the equality is read as:
$$
((\apure_M\, f) \appl m_a) \appl (\apure_M\, b)
$$
which means that we can apply the interchange law to it.
In the application of the law we abstract a variable $h$ of type $B\rightarrow C$:
$$
\begin{array}{ll}
(\apure_M\, f) \appl m_a \appl (\apure_M\, b) \\
{} =  (\apure_M\, (\lambda h. h\, b)) \appl ((\apure_M\, f) \appl m_a)
 & \mbox{by interchange law of }M\\
{} =  ((\apure_M\, (\lambda h. h\, b)) \alift{\comp} (\apure_M\, f)) \appl m_a
 & \mbox{by composition law of }M\\
{} =  (\apure_M ( (\lambda h. h\, b) \comp f ) ) \appl m_a
 & \mbox{by Lemma \ref{lemma:pure_lift}}\\
{} =  (\apure_M (\lambda a. f\, a\, b )) \appl m_a
 & \mbox{by definition of composition}\\
\end{array}
$$
\end{proof}

\begin{lemma}
If the base functor $M$ is an applicative, then monsters with this base functor satisfy the applicative interchange law:
$$
\sigma_f \appl (\apure_{\stream{M}}\,a) = (\apure_{\stream{M}}\,(\lambda f. f\,a)) \appl \sigma_f
$$
Assume that $a:A$ and $\sigma_f = \mcons\,m_f$ for some $m_f:M\,((A\rightarrow B)\times \stream{M}\,(A\rightarrow B))$.
\end{lemma}
\begin{proof}
$$
\begin{array}{ll}
\sigma_f \appl (\apure_{\stream{M}}\,a) = (\mcons\,m_f) \appl (\apure_{\stream{M}}\,a) \\
{}= (\mcons\,m_f) \appl (\mcons\,(\apure_M\,\langle a, \apure_{\stream{M}}\,a\rangle))
  & \mbox{by Lemma \ref{lemma:monster_pure}}\\
{}= \mcons\,(m_f \alift{\pappl} (\apure_M\,\langle a, \apure_{\stream{M}}\,a\rangle))
  & \mbox{by definition of }\appl\\
{}= \mcons\,((\apure_M\,(\pappl)) \appl m_f \appl (\apure_M\,\langle a, \apure_{\stream{M}}\,a\rangle))
  & \mbox{by definition of }\alift{-}\\
{}= \mcons \, ((\apure_M\,(\lambda \pair{f}{\phi} . \pair{f}{\phi} \pappl \pair{a}{\apure_{\stream{M}}\,a})) \appl m_f)
  & \mbox{by Lemma \ref{lemma:applicative_flip}}\\
{}= \mcons\,((\apure_M\,(\lambda \pair{f}{\phi} . \pair{f a}{\phi \appl (\apure_{\stream{M}}\,a)})) \appl m_f)
  & \mbox{by definition of } \pappl \\
{}= \mcons\,((\apure_M\,(\lambda \pair{f}{\phi} . \pair{f a}{(\apure_{\stream{M}}\,(\lambda f . f\, a)) \appl \phi})) \appl m_f)
  & \mbox{\bf by coinduction hypothesis} \\
{}= \mcons\,(\apure_M\,(\lambda \pair{f}{\phi}.
    \pair{\lambda f . f\, a}{\apure_{\stream{M}}\,(\lambda f . f\, a))}
    \pappl \pair{f}{\phi}
    ) \appl m_f)
  & \mbox{by definition of } \pappl \\
{}= \mcons\,((\apure_M\,(\pappl)) \appl (\apure_M\,\langle \lambda f. f\,a, \apure_{\stream{M}}\,(\lambda f. f\,a)  \rangle) \appl m_f)
  & \mbox{by the homomorphism law for }M \\
{}= \mcons\,((\apure_M\,\langle \lambda f. f\,a, \apure_{\stream{M}}\,(\lambda f. f\,a)  \rangle) \alift{\pappl} m_f)
  & \mbox{by definition of }\alift{-}\\
{}= (\mcons\,(\apure_M\,\langle \lambda f. f\,a, \apure_{\stream{M}}\,(\lambda f. f\,a)  \rangle)) \appl (\mcons\,m_f)
  & \mbox{by definition of }\appl \\
{}= (\apure_{\stream{M}}\,(\lambda f. f\,a)) \appl (\mcons\,m_f)
  & \mbox{by Lemma \ref{lemma:monster_pure}} \\
{} = (\apure_{\stream{M}}\,(\lambda f. f\,a)) \appl \sigma_f
\end{array}
$$
\end{proof}


% Proof of composition law with M applicative

To prove the final applicative law, we first need three lemmas (mostly to make the upcoming reasoning clearer). This law is much trickier than the previous ones, and requires many rewrite steps.

\begin{lemma}
$$
\lambda g . ((\comp) \comp (\comp) \comp (\pappl))\, g\, (\pappl) = \lambda g . \lambda f . \lambda a . (g\, \pappl (f \pappl a))
$$
\end{lemma}
\begin{proof}
$$
\begin{array}{ll}
\lambda g . ((\comp) \comp (\comp) \comp (\pappl))\, g\, (\pappl) \\
{}= \lambda g . (\lambda x . (\comp) ((\comp) (x\, \pappl)))\, g\, (\pappl)
 &\mbox{by definition of }\comp\\
{}= \lambda g . (\comp) ((\comp) (g\, \pappl))\, (\pappl) 
& \mbox{by function application}\\
{}= \lambda g . ((\comp) (g\, \pappl)) \comp (\pappl) 
& \mbox{by function application}\\
{}= \lambda g . \lambda f . ((\comp) (g\, \pappl)) (f\, \pappl) 
 &\mbox{by definition of }\comp\\
{}= \lambda g . \lambda f . (g\, \pappl) \comp (f\, \pappl)
& \mbox{by function application}\\
{}= \lambda g . \lambda f . \lambda a . (g\, \pappl) ((f\, \pappl)\, a) ) 
& \mbox{by definition of }\comp\\
{}= \lambda g . \lambda f . \lambda a . (g\, \pappl (f \pappl a))
& \mbox{by function application(s)}\\
\end{array}
$$
\end{proof}

\begin{lemma}
$$
(((\pappl)\, \comp)\, \comp\, ((\pappl)\, \comp\, (\pair{(\comp)}{\apure_{\stream{M}}\,(\comp)}\, \pappl))) = \lambda g. \lambda f. \lambda a. ( ( (\pair{(\comp)}{\apure_{\stream{M}}\,(\comp)})\, \pappl\, g )\, \pappl\, f )\, \pappl\, a
$$
In the proof, we define $c = \pair{(\comp)}{\apure_{\stream{M}}\,(\comp)}$ for readability.
\end{lemma}
\begin{proof}
$$
\begin{array}{ll}
(((\pappl)\, \comp)\, \comp\, ((\pappl)\, \comp\, (c\, \pappl)))\\
{}= \lambda g. ((\pappl)\, \comp) ((\lambda g . (\pappl) ((c\, \pappl)\, g))\, g)
&\mbox{by definition of}\comp\mbox{(used twice)}\\
{}= \lambda g. ((\pappl)\, \comp) ((\pappl) (c\, \pappl g))
&\mbox{by function application(s)}\\
{}= \lambda g. (\pappl) \comp ((c \pappl g)\, \pappl)
&\mbox{by function application(s)}\\
{}= \lambda g. \lambda f . (\pappl) (((c \pappl g)\, \pappl)\, f)
&\mbox{by definition of }\comp\\
{}= \lambda g. \lambda f . (((c \pappl g) \pappl f)\, \pappl) 
&\mbox{by function application(s)}\\
{}= \lambda g. \lambda f . \lambda a . ((c \pappl g)\pappl f) \pappl a
&\mbox{trivial}\\
{}= \lambda g. \lambda f . \lambda a . ((\pair{(\comp)}{\apure_{\stream{M}}\,(\comp)} \pappl g)\pappl f) \pappl a
&\mbox{definition of }c\\
\end{array}
$$
\end{proof}

\begin{lemma}
$$
\lambda g . \lambda f . \lambda a .(g\, \pappl (f \pappl a)) = \lambda g. \lambda f. \lambda a. ( ( (\pair{(\comp)}{\apure_{\stream{M}}\,(\comp)}) \pappl g ) \pappl f ) \pappl a
$$
\end{lemma}
\begin{proof}
\ccomm{Still todo, but should be fairly do-able by observing canonical forms of the inputs considering the functions they're being applied to (namely $(\pappl)$)}
$$
$$
\end{proof}

\begin{lemma}
If the base functor $M$ is an applicative functor, then the corresponding monster satisfies the composition law:
\begin{proof}

We prove this by starting with both the left and right-hand-side of the law, and meeting in the middle.
$$
\begin{array}{ll}
\sigma_g \appl (\sigma_f \appl \sigma_a) \\
 = (\mcons\,m_g) \appl ((\mcons\,m_f) \appl (\mcons\,m_a))\\
{}= \mcons\,(m_g \alift{\pappl} (m_f \alift{\pappl} m_a)) \\
\mbox{by definition of}\appl\mbox{for monsters} \\
{}= \mcons\,((\apure\, (\pappl)) \appl m_g \appl ((\apure\, (\pappl)) \appl m_f \appl m_a)) \\
 \mbox{by definition of }\alift{-}\\
{}= \mcons\,( (  ((\apure\, (\pappl)) \appl m_g) \alift{\comp} ((\apure\, (\pappl)) \appl m_f)  ) \appl m_a) \\
 \mbox{by composition law for }M \\
{}= \mcons\,( (  (\apure\, (\comp)) \appl  ((\apure\, (\pappl)) \appl m_g) \appl ((\apure\, (\pappl)) \appl m_f)  ) \appl m_a) \\
 \mbox{by definition of }\alift{-}\\
{}= \mcons\,( (  ( ((\apure\, (\comp)) \alift{\comp}  (\apure\, (\pappl))) \appl m_g ) \appl ((\apure\, (\pappl)) \appl m_f)  ) \appl m_a) \\
 \mbox{by composition law for }M \\
{}= \mcons\,( (  ( (\apure\, ((\comp) \comp (\pappl)) ) \appl m_g ) \appl ((\apure\, (\pappl)) \appl m_f)  ) \appl m_a)\\
 \mbox{by Lemma \ref{lemma:pure_lift}}\\
{}= \mcons\,( (  (( (\apure\, ((\comp) \comp (\pappl)) ) \appl m_g ) \alift{\comp} (\apure\, (\pappl))) \appl m_f  ) \appl m_a)\\
 \mbox{by composition law for }M \\
{}= \mcons\,( (  ( (\apure\, (\comp)) \appl ( (\apure\, ((\comp) \comp (\pappl)) ) \appl m_g ) \appl (\apure\, (\pappl)) ) \appl m_f  ) \appl m_a)\\
 \mbox{by definition of }\alift{-} \\
{}= \mcons\,( (  ( (  ((\apure\, (\comp)) \alift{\comp}  (\apure\, ((\comp) \comp (\pappl)) )) \appl m_g  ) \appl (\apure\, (\pappl)) ) \appl m_f  ) \appl m_a)\\
 \mbox{by composition law for }M \\
{}= \mcons\,( (  ( (  (\apure\, ((\comp) \comp (\comp) \comp (\pappl))) \appl m_g  ) \appl (\apure\, (\pappl)) ) \appl m_f  ) \appl m_a)\\
 \mbox{by Lemma \ref{lemma:pure_lift}}\\
{}= \mcons\,( (  (  \big(\apure\, (\lambda g . ((\comp) \comp (\comp) \comp (\pappl))\, g\, (\pappl) ) \big) \appl m_g   ) \appl m_f  ) \appl m_a)\\
 \mbox{by Lemma \ref{lemma:applicative_flip}}\\
\end{array}
$$
Now to meet in the middle
$$
\begin{array}{ll}
(\sigma_g \alift{\comp} \sigma_f) \appl \sigma_a \\
{}= (\apure_{\stream{M}}\,(\comp) \appl \sigma_g \appl \sigma_f) \appl \sigma_a \\
\mbox{by definition of }\alift{-}\\
{}= \mcons\, ((\apure_M\,\pair{(\comp)}{\apure_{\stream{M}}\,(\comp)}) \alift{\pappl} m_g \alift{\pappl} m_f \alift{\pappl} m_a)\\
\mbox{by definition of}\appl\mbox{for monsters}\\
{}= \mcons\, (((\apure_M\,(\pappl)) \appl (\apure_M\,\pair{(\comp)}{\apure_{\stream{M}}\,(\comp)}) \appl m_g) \alift{\pappl} m_f \alift{\pappl} m_a)\\
\mbox{by definition of }\alift{-}\\
{}= \mcons\, (((\apure_M\,(\pair{(\comp)}{\apure_{\stream{M}}\,(\comp)}\, \pappl)) \appl m_g) \alift{\pappl} m_f \alift{\pappl} m_a)\\
 \mbox{by homomorphism law of }M\\
{}= \mcons\, ((\apure_M\,(\pappl) \appl ((\apure_M\,(\pair{(\comp)}{\apure_{\stream{M}}\,(\comp)}\, \pappl)) \appl m_g) \appl m_f) \alift{\pappl} m_a)\\
\mbox{by definition of }\alift{-}\\
{}= \mcons\, ((((\apure_M\,(\pappl) \alift{\comp} (\apure_M\,(\pair{(\comp)}{\apure_{\stream{M}}\,(\comp)}\, \pappl))) \appl m_g) \appl m_f) \alift{\pappl} m_a)\\
\mbox{by composition law of }M\\
{}= \mcons\, ((((\apure_M\,((\pappl) \comp (\pair{(\comp)}{\apure_{\stream{M}}\,(\comp)}\, \pappl))) \appl m_g) \appl m_f) \alift{\pappl} m_a)\\
\mbox{by Lemma \ref{lemma:pure_lift}}\\
{}= \mcons\, ( (\apure_M\,(\pappl)) \appl (((\apure_M\,((\pappl) \comp (\pair{(\comp)}{\apure_{\stream{M}}\,(\comp)}\, \pappl))) \appl m_g) \appl m_f) \appl m_a)\\
\mbox{by definition of }\alift{-}\\
{}= \mcons\, ( ( ((\apure_M\,(\pappl)) \alift{\comp} ((\apure_M\,((\pappl) \comp (\pair{(\comp)}{\apure_{\stream{M}}\,(\comp)}\, \pappl))) \appl m_g)) \appl m_f) \appl m_a) \\
\mbox{by composition law of }M\\
{}= \mcons\, ( ( ( (\apure_M\,(\comp)) \appl (\apure_M\,(\pappl)) \appl ((\apure_M\,((\pappl) \comp (\pair{(\comp)}{\apure_{\stream{M}}\,(\comp)}\, \pappl))) \appl m_g)) \appl m_f) \appl m_a) \\
\mbox{by definition of }\alift{-}\\
{}= \mcons\, ( ( ( (\apure_M\,((\pappl)\, \comp)) \appl ((\apure_M\,((\pappl) \comp (\pair{(\comp)}{\apure_{\stream{M}}\,(\comp)}\, \pappl))) \appl m_g) ) \appl m_f) \appl m_a) \\
 \mbox{by homomorphism law of }M\\
 {}= \mcons\, ( ( ( ( (\apure_M\,((\pappl)\, \comp)) \alift{\comp} (\apure_M\,((\pappl) \comp (\pair{(\comp)}{\apure_{\stream{M}}\,(\comp)}\, \pappl)))  ) \appl m_g ) \appl m_f) \appl m_a) \\
\mbox{by composition law of }M\\
 {}= \mcons\, ( ( ( \big(\apure_M\,(((\pappl)\, \comp) \comp ((\pappl) \comp (\pair{(\comp)}{\apure_{\stream{M}}\,(\comp)}\, \pappl)))\big) \appl m_g ) \appl m_f) \appl m_a) \\
\mbox{by Lemma \ref{lemma:pure_lift}}\\
\end{array}
$$
\end{proof}
\end{lemma}









% Proof of composition law with M monad

\paragraph{Attempt to prove the composition law when $M$ is a monad.}

Finally, the composition law for monsters is more challenging.
We have been able to prove it only by assuming extra properties for the base functor $M$.
Specifically we assume $M$ to be a monad.
In that case the applicative methods $\apure$ and $\appl$ can be defined in terms of $\return$ and $\bind$ and the applicative laws follow from the monad laws:
$$
\apure = \return
\qquad
m_f \appl m_a = m_f \bind \lambda f. (m_a \bind \return\comp f)
$$

We can then prove a couple of useful equations relating applicative expressions with simpler monadic ones.

\begin{lemma}\label{lemma:pure_app_bind}
Assuming $M$ is a monad, 
if $f:A\rightarrow B$ and $m_a:M\,A$, then:
$$
(\apure\,f)\appl m_a = m_a \bind \return\comp f
$$
\end{lemma}
\begin{proof}
$$
\begin{array}{ll}
(\apure\,f)\appl m_a\\
{}= (\return\,f) \bind \lambda f. (m_a \bind \return\comp f)
  & \mbox{by definition}\\
{}= m_a \bind \return\comp f
  & \mbox{by the left-identity law}
\end{array}
$$
\end{proof}

\begin{lemma}\label{lemma:pure_app_pure_bind}
Assuming $M$ is a monad, 
if $g:A\rightarrow B\rightarrow C$, $m_a:M\,A$, and $b:B$ then:
$$
(\apure\,g) \appl m_a \appl (\apure\,b) = m_a \bind \lambda a. \return\,(g\,a\,b)
$$
\end{lemma}
\begin{proof}
$$
\begin{array}{ll}
(\apure\,g) \appl m_a \appl (\apure\,b)\\
{}= (m_a \bind \return\comp g) \appl (\return\,b)
  & \mbox{by Lemma \ref{lemma:pure_app_bind}}\\
{}= (m_a \bind \return\comp g) \bind \lambda h. (\return\,b \bind \return \comp h)
  & \mbox{by definition}\\
{}= (m_a \bind \return\comp g) \bind \lambda h. \return\,(h\,b))
  & \mbox{by the left-identity law}\\
{}= m_a \bind \lambda a. (\return\,(g\,a) \bind \lambda h. \return\,(h\,b))
  & \mbox{by the associativity law}\\
{}= m_a \bind \lambda a. \return\,(g\,a\,b))
  & \mbox{by the left-identity law}
\end{array}
$$
\end{proof}


\begin{lemma}\label{lemma:bind_appl}
Let $M$ be a monad, $m_a:M\,A$, $g:A \rightarrow M\,(B\rightarrow C)$, $m_b:M\,B$; then:
$$
(m_a \bind g) \appl m_b = m_a \bind \lambda a. (g\,a) \appl m_b
$$
\end{lemma}
\begin{proof}
$$
\begin{array}{ll}
(m_a \bind g) \appl m_b \\
{}= (m_a \bind g) \bind \lambda h. (m_b \bind \return \comp h)
  & \mbox{by characterization of }\appl\mbox{ for monads}\\
{}= m_a \bind \lambda a. (g\,a) \bind \lambda h. (m_b \bind \return \comp h)
  & \mbox{by monadic associativity}\\
{}= m_a \bind \lambda a. (g\,a) \appl m_b
  & \mbox{by characterization of }\appl\mbox{ for monads}\\  
\end{array}
$$
\end{proof}

\begin{lemma}
For any binary operator $(\otimes):A\rightarrow B \rightarrow C$ and actions $m_a:M\,A$, $b_b:B\,B$, we have:
$$
m_a \alift{\otimes} m_b = m_a \bind \lambda a. m_b \bind \lambda b. \return\,(a \otimes b)
$$
\end{lemma}
\begin{proof}
$$
\begin{array}{ll}
m_a \alift{\otimes} m_b \\
{}= (\apure\;(\otimes)) \appl m_a \appl m_b
  & \mbox{by definition of }\alift{-}\\
{}= (m_a \bind \return \comp (\otimes)) \appl m_b
  & \mbox{by Lemma \ref{lemma:pure_app_bind}}\\
{}= m_a \bind \lambda a. \return\,((\otimes)\,a) \appl m_b
  & \mbox{by Lemma \ref{lemma:bind_appl}}\\
{}= m_a \bind \lambda a. m_b \bind \return \comp ((\otimes)\,a)
  & \mbox{by Lemma \ref{lemma:pure_app_bind}}\\
{}= m_a \bind \lambda a. m_b \bind \lambda b. \return (a \otimes b)
  & \mbox{by definition of composition}
\end{array}
$$
\end{proof}

\begin{lemma}
If the base functor $M$ is a monad, then monsters satisfy the applicative composition law.
For $\sigma_a:\stream{M}\,A$, $\sigma_f : \stream{M}\,(A\rightarrow B)$, $\sigma_g: \stream{M}\,(B\rightarrow C)$, we have:
$$
\sigma_g \appl (\sigma_f \appl \sigma_a) = (\sigma_g \alift{\comp} \sigma_f) \appl \sigma_a
$$
\end{lemma}
\begin{proof}
We assume that $\sigma_g = \mcons\,m_g$ for some $m_g:M\,((A\rightarrow B)\times \stream{M}\,(A\rightarrow B)$, $\sigma_f = \mcons\,m_g$ for some $m_f:M\,((B\rightarrow C)\times \stream{M}\,(B\rightarrow C)$, and $\sigma_a = \mcons\,m_a$ for some $m_a:M\,(A\times \stream{M}\,A$.

By the definition of $\appl$ for monsters, the left-had side of the equation reduces to:
$$
\begin{array}{l}
\sigma_g \appl (\sigma_f \appl \sigma_a) 
 = (\mcons\,m_g) \appl ((\mcons\,m_f) \appl (\mcons\,m_a))\\
{}= \mcons\,(m_g \alift{\pappl} (m_f \alift{\pappl} m_a))
\end{array}
$$

Similarly, by the definition of $\alift{-}$ and $\appl$ for monsters, the right-hand side reduces to:
$$
(\sigma_g \alift{\comp} \sigma_f) \appl \sigma_a
  = \mcons((\apure_M\,\langle (\comp), \apure_{\stream{M}}\,(\comp)\rangle)
    \alift{\pappl} m_g \alift{\pappl} m_f \alift{\pappl} m_a)
$$

We then need to prove that:
$$
m_g \alift{\pappl} (m_f \alift{\pappl} m_a)
  = (\apure_M\,\langle (\comp), \apure_{\stream{M}}\,(\comp)\rangle)
    \alift{\pappl} m_g \alift{\pappl} m_f \alift{\pappl} m_a
$$
\vcomm{I'm still working on this: not easy!}
\end{proof}
