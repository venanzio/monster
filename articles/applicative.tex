\section{Monsters are Applicatives}

Applicative functors \cite{mcbride/paterson:2008}
extend the mapping operation by allowing function sequencing under the functor.
The Applicative class has two methods: $\apure$, that injects single values into the functor, and $\appl$, that applies functions under the functor.

We assume that the type operator $M$ is an applicative functor, that is, it has methods:
$$
\begin{array}{l}
\apure : A \rightarrow M\,A\\
(\appl): M\,(A\rightarrow B) \rightarrow M\,A \rightarrow M\,B
\end{array}
$$
satisfying the four equational laws regulating the interaction of sequencing and pure values and requiring associativity of application.

For the base functor $M$, the laws take the following form, where
 $a:A$, $f:A\rightarrow B$,
$m_a:M\,A$, $m_f:M\,(A\rightarrow B)$, $m_g:M\,(B\rightarrow C)$.
$$
\begin{array}{l@{\qquad}l}
(\apure\,\id) \appl m_a = m_a
  & \mbox{Identity} \\
(\apure\,f) \appl (\apure\,a) = \apure\,(f\,a)
  & \mbox{Homomorphism} \\
m_f \appl (\apure\,a) = (\apure\,(\lambda f. f\,a)) \appl m_f
  & \mbox{Interchange} \\
m_g \appl (m_f \appl m_a) = (m_g \alift{\comp} m_f) \appl m_a
  & \mbox{Composition}
\end{array}
$$

Functoriality of $M$ follows from these laws, with functorial mapping defined as
$
M\,f\,m_a = (\apure\,f) \appl m_a.
$
The interchange law implies that
$
M\,f\,(\apure\,a) = \apure\,(f\,a).
$

A typical use of applicative functors is to apply a function of many arguments to several applicative values.
If $g:A_0\rightarrow A_1 \rightarrow \cdots \rightarrow A_n \rightarrow B$ and $m_0:M\,A_0, m_1:M\,A_1, \ldots, m_n:M\,A_n$ , then:
$$
(\apure\,g) \appl m_0 \appl m_1 \appl \cdots \appl m_n : M\,B
$$

In particular, if $g$ is an infix binary operator $(\oplus) : A \rightarrow B \rightarrow C$, then we use the notation:
$$
m_a \alift{\oplus} m_b = (\apure\,(\oplus)) \appl m_a \appl m_b
$$

We will show that $\stream{M}$ is also applicative.
In order to define the methods, we need some auxiliary functions on applicative monsters.
First of all, a simplified version of $\mcons$ that appends a single value in front of a monster.
This in turn uses a similar operator for functors, which appends an $M$-action to the front of a monster
$$
\begin{array}{l}
(\fcons): M\,A \rightarrow \stream{M}\,A \rightarrow \stream{M}\,A\\
m \fcons \sigma = \mcons\, (M\,(\lambda a. \langle a, \sigma\rangle)\,m)\\
\,\\
(\acons): A \rightarrow \stream{M}\,A \rightarrow \stream{M}\,A\\
a \acons \sigma = (\apure\, a) \fcons \sigma
\end{array}
$$

The $\apure$ method for monsters then consists in repeating the same element forever:
$$
\begin{array}{l}
\apure : A \rightarrow \stream{M}\,A\\
\apure\,a = a \acons \apure\,a
\end{array}
$$

Using the applicative laws for $M$, we can give a simplified characterization of pure monsters.
The term we use combine the use of $\apure$ on $M$ and on $\stream{M}$.
This could be confusing, so we explicitely write the functor as subscript.
\begin{lemma}\label{lemma:monster_pure}
$$
\apure_{\stream{M}}\,a = \mcons\,(\apure_M\,\langle a, \apure_{\stream{M}}\,a\rangle)
$$
\end{lemma}
\begin{proof}
By unfolding definitions and using the identity law for the applicative functor $M$:
$$
\begin{array}{ll}
\apure_{\stream{M}}\,a \\
{}= a \acons \apure_{\stream{M}}\,a
  & \mbox{by definition of }\apure_{\stream{M}} \\
{}= (\apure_M\,a) \fcons (\apure_{\stream{M}}\,a)
  & \mbox{by definition of }\acons\\
{}=  \mcons\, (M\,(\lambda a. \langle a, \apure_{\stream{M}}\,a\rangle)\,(\apure_M\,a))
  & \mbox{by definition of }\fcons\\
{}= \mcons\, ((\apure_M\,(\lambda a. \langle a, \apure_{\stream{M}}\,a\rangle)) \appl (\apure_M\,a))
  & \mbox{by functoriality of applicatives}\\
{}= \mcons\, (\apure_M\,((\lambda a. \langle a, \apure_{\stream{M}}\,a\rangle)\,a))
  & \mbox{by the homomorphism law for }M\\
{}= \mcons\, (\apure_M\,\langle a, \apure_{\stream{M}}\,a\rangle)
  & \mbox{by function application}
\end{array}
$$
\end{proof}

We define the function application method by mapping straight function application on the heads and recursive calls on the tails through functorial and applicative lifting:
$$
\begin{array}{l}
(\appl) : \stream{M}\,(A\rightarrow B) \rightarrow \stream{M}\,A \rightarrow \stream{M}\,B\\
(\mcons\,m_f) \appl (\mcons\,m_a)
= \mcons\,(m_f \alift{\pappl} m_a)\\
\qquad \where\;
\langle f,\phi\rangle \pappl \langle a,\sigma\rangle 
= \langle f\,a, \phi \appl \sigma \rangle
\end{array}
$$

This definition recursively applies $\appl$ indirectly in the second components of the arguments of the $\pappl$ operator.
This is lifted to $\alift{\pappl}$, which distributes down through the components of the applicative values $m_f$ and $m_a$, and finally guarded by the constructor $\mcons$.
This guarantees the soundness of the definition according to the {\em guardedness by constructors} criterion.

We aim to show that these definitions satisfy the applicative laws.
We assume that the laws are satisfied by the base functor and we aim to prove them for the monster functor.

\vcomm{I leave this year with the conjecture: to be placed at the end as a Theorem when we have the proofs.}
Preliminary investigation and analysis of specific instances suggest that this is the case for monsters.
A full proof is one of the goals of future work.
\begin{conjecture}\label{lemma:appl_laws}
If $M$ is an applicative functor, $\stream{M}$ is also an applicative functor.
That is, the following laws are satisfied, for every $a:A$, $f:A\rightarrow B$, $\sigma_a:\stream{M}\,A$, $\sigma_f : \stream{M}\,(A\rightarrow B)$, $\sigma_g: \stream{M}\,(B\rightarrow C)$:
$$
\begin{array}{l}
(\apure\,\id) \appl \sigma_a = \sigma_a \\
(\apure\,f) \appl (\apure\,a) = \apure\,(f\,a) \\
\sigma_f \appl (\apure\,a) = (\apure\,(\lambda f. f\,a)) \appl \sigma_f \\
\sigma_g \appl (\sigma_f \appl \sigma_a) = (\sigma_g \alift{\comp} \sigma_f) \appl \sigma_a
\end{array}
$$
\end{conjecture}

The new operator $\alift{\pappl}$ has a direct simplification on pure values, which will be very useful in the proofs of the laws.
\begin{lemma}\label{lemma:pappl}
If $f:A\rightarrow B$, $m_f:\stream{M}\,(A\rightarrow B)$, $a:A$, $m_a:\stream{M}\,A$, then:
$$
(\apure_M\,\langle f, m_f\rangle) \alift{\pappl} (\apure_M\,\langle a, m_a\rangle) = \apure_M \langle f\,a, m_f \appl m_a \rangle
$$
\end{lemma}
\begin{proof}
$$
\begin{array}{ll}
(\apure_M\,\langle f, m_f\rangle) \alift{\pappl} (\apure_M\,\langle a, m_a\rangle) \\
{}= (\apure_M\,(\pappl)) \appl (\apure_M\,\langle f, m_f\rangle) \appl (\apure_M\,\langle a, m_a\rangle)
  & \mbox{by definition of }\alift{-}\\
{}= \apure_M\,(\langle f, m_f\rangle \pappl \langle a, m_a\rangle)
  & \mbox{by the homomorphism law for }M\\
{}= \apure_M\,\langle f\,a, m_f \appl m_a \rangle
  & \mbox{by definition of }\pappl
\end{array}
$$
\end{proof}


In the proofs, we need to avoid confusion between the applicative operations for $M$ and those for $\stream{M}$.
We assume that the laws are valid for $M$ and we want to prove them for $\stream{M}$.
In the formulas, the two sets of operations will occur in the same terms, potentially leading to confusion.
It is clear from the type of the arguments which version is intended, but it may be challenging to keep track of the types.
Therefore we will use a slightly heavier but clearer notation: we use $M$ as subscript for $\apure$ when the $M$ version is intended, $\stream{M}$ when the monster version is intended; we consistently use $\sigma$ with subscripts to denote monsters and $m$ with subscripts to denote $M$-actions; we explicitely write the argument type of identity functions as subscripts.
We won't distinguish the occurrences of $\appl$ for $M$ and $\stream{M}$ with subscripts, but they should be clear given the previous notational conventions.

\begin{lemma}
Monsters satisfy the applicative identity law:
$$
(\apure_{\stream{M}}\,\id_A) \appl \sigma_a = \sigma_a
$$
We will assume that the $\sigma_a$ has the canonical form:
$\sigma_a = \mcons\,m$ where $m:M\,(A\times \stream{M}A).$
\end{lemma}
\begin{proof}
Most of the proof is by straightforward equational reasoning, unfolding definitions and using the applicative laws for $M$.

The only unusual step is the application of the {\em coinduction hypothesis}.
Recall that this means that we can assume that the statement to prove is already true, as long as it is invoked directly on direct arguments of the monster constructor.
$$
\begin{array}{ll}
(\apure_{\stream{M}}\,\id_A) \appl \sigma_a \\
{}= (\id_A \acons (\apure_{\stream{M}}\,\id_A)) \appl \sigma_a
  & \mbox{by definition of }\apure \\
{}= ((\apure_M\,\id_A) \fcons (\apure_{\stream{M}}\,\id_A)) \appl \sigma_a
  & \mbox{by definition of }\acons \\
{}= (\mcons\,(M\,(\lambda f. \langle f, (\apure_{\stream{M}}\,\id_A)\rangle)\,(\apure_M\,\id_A))) \appl \sigma_a
  & \mbox{by definition of }\fcons \\
{}= (\mcons\,(\apure_M\,\langle \id_A, (\apure_{\stream{M}}\,\id_A)\rangle)) \appl \sigma_a
  & \mbox{by the interchange law} \\
{}= (\mcons\,(\apure_M\,\langle \id_A, (\apure_{\stream{M}}\,\id_A)\rangle)) \appl (\mcons\,m)
  & \mbox{canonical form of }\sigma_a\\
{}= \mcons\,(\apure_M\,\langle \id_A, (\apure_{\stream{M}}\,\id_A)\rangle)) \alift{\pappl}  m)
  & \mbox{by definition of }\appl \\
{}= \mcons\,((\apure_{M}\,\pappl) \appl (\apure_M\,\langle \id_A, (\apure_{\stream{M}}\,\id_A)\rangle) \appl  m)
  & \mbox{by definition of }\alift{-} \\
{}= \mcons\,(\apure_M\,((\pappl)\,\langle \id_A, (\apure_{\stream{M}}\,\id_A)\rangle) \appl  m)
  & \mbox{by the homomorphism law}\\
{}= \mcons\,(\apure_M\,(\lambda \langle a,\sigma_a\rangle. \langle \id_A, (\apure_{\stream{M}}\,\id_A)\rangle \pappl \langle a,\sigma_a\rangle) \appl m)
  & \mbox{expansion of the section}\\
{}= \mcons\,(\apure_M\,(\lambda \langle a,\sigma_a\rangle. \langle \id_A\,a, (\apure_{\stream{M}}\,\id_A) \appl \sigma_a\rangle) \appl m)
  & \mbox{definition of }\pappl\\
{}= \mcons\,(\apure_M\,(\lambda \langle a,\sigma_a\rangle. \langle a, \sigma_a\rangle) \appl m)
  & \mbox{\bf by coinduction hypothesis}\\
{}= \mcons\,(\apure_M\,\id_{A\times\stream{M}A} \appl m)
  & \mbox{trivial}\\
{}= \mcons\,m = \sigma_a
  & \mbox{by the identity law for }M
\end{array}
$$
In the step that makes use of the coinduction hypothesis, we circularly use the lemma's statement that $(\apure_{\stream{M}}\,\id_A) \appl \sigma_a = \sigma_a$.
The right-hand side occurs under an application of the constructor $\mcons$, inside an application of a pure value. 
This stuctural positioning of the term ensure that the application of the coinductive hypothesis is sound.

\vcomm{This is intuitively OK, but it may be worth exploring it further and making it more rigorous by studying how application of pure functions generate the structure of the result.}
\end{proof}

\begin{lemma}
Monsters satisfy the applicative homomorphism law:
$$
(\apure\,f) \appl (\apure\,a) = \apure\,(f\,a)
$$
\end{lemma}
\begin{proof}
$$
\begin{array}{ll}
(\apure\,f) \appl (\apure\,a)\\
{}= (\mcons\,(\apure_M\,\langle f, \apure_{\stream{M}}\,f\rangle)) \appl
    (\mcons\,(\apure_M\,\langle a, \apure_{\stream{M}}\,a\rangle))
  & \mbox{by Lemma \ref{lemma:monster_pure}}\\
{}= \mcons\,((\apure_M\,\langle f, \apure_{\stream{M}}\,f\rangle) \alift{\pappl}
             (\apure_M\,\langle a, \apure_{\stream{M}}\,a\rangle))
  & \mbox{by definition of }\appl\\
{}= \mcons\,(\apure_M\,(\langle f, \apure_{\stream{M}}\,f\rangle \appl \langle a, \apure_{\stream{M}}\,a\rangle))
  & \mbox{by Lemma }\ref{lemma:pappl}\\
{}= \mcons\,(\apure_M\,\langle f\,a, \apure_{\stream{M}}\,(f\,a)\rangle)
  & \mbox{by coinduction hypothesis}\\
{}= \apure_{\stream{M}}\,(f\,a)
  & \mbox{by lemma }\ref{lemma:monster_pure}
\end{array}
$$
\end{proof}

The interchange law is more challenging.
We have been able to prove it only by assuming extra properties for the base functor $M$.
Specifically we assume $M$ to be a monad.
In that case the applicative methods $\apure$ and $\appl$ can be defined in terms of $\return$ and $\bind$ and the applicative laws follow from the monad laws:
$$
\apure = \return
\qquad
m_f \appl m_a = m_f \bind \lambda f. (m_a \bind \return\comp f)
$$

We can then prove a couple of useful equations relating applicative expressions with simpler monadic ones.

\begin{lemma}\label{lemma:pure_app_bind}
Assuming $M$ is a monad, 
if $f:A\rightarrow B$ and $m_a:M\,A$, then:
$$
(\apure\,f)\appl m_a = m_a \bind \return\comp f
$$
\end{lemma}
\begin{proof}
$$
\begin{array}{ll}
(\apure\,f)\appl m_a\\
{}= (\return\,f) \bind \lambda f. (m_a \bind \return\comp f)
  & \mbox{by definition}\\
{}= m_a \bind \return\comp f
  & \mbox{by the left-identity law}
\end{array}
$$
\end{proof}

\begin{lemma}\label{lemma:pure_app_pure_bind}
Assuming $M$ is a monad, 
if $g:A\rightarrow B\rightarrow C$, $m_a:M\,A$, and $b:B$ then:
$$
(\apure\,g) \appl m_a \appl (\apure\,b) = m_a \bind \lambda a. \return\,(g\,a\,b)
$$
\end{lemma}
\begin{proof}
$$
\begin{array}{ll}
(\apure\,g) \appl m_a \appl (\apure\,b)\\
{}= (m_a \bind \return\comp g) \appl (\return\,b)
  & \mbox{by Lemma \ref{lemma:pure_app_bind}}\\
{}= (m_a \bind \return\comp g) \bind \lambda h. (\return\,b \bind \return \comp h)
  & \mbox{by definition}\\
{}= (m_a \bind \return\comp g) \bind \lambda h. \return\,(h\,b))
  & \mbox{by the left-identity law}\\
{}= m_a \bind \lambda a. (\return\,(g\,a) \bind \lambda h. \return\,(h\,b))
  & \mbox{by the associativity law}\\
{}= m_a \bind \lambda a. \return\,(g\,a\,b))
  & \mbox{by the left-identity law}
\end{array}
$$
\end{proof}

\begin{lemma}
If the base functor $M$ is a monad, then monsters satisfy the applicative interchange law:
$$
\sigma_f \appl (\apure_{\stream{M}}\,a) = (\apure_{\stream{M}}\,(\lambda f. f\,a)) \appl \sigma_f
$$
\end{lemma}
\begin{proof}
Assume that $\sigma_f = \mcons\,m_f$ for some $m_f:M\,((A\rightarrow B)\times \stream{M}\,(A\rightarrow B))$.
$$
\begin{array}{ll}
\sigma_f \appl (\apure_{\stream{M}}\,a) = (\mcons\,m_f) \appl (\apure_{\stream{M}}\,a) \\
{}= (\mcons\,m_f) \appl (\mcons\,(\apure_M\,\langle a, \apure_{\stream{M}}\,a\rangle))
  & \mbox{by Lemma \ref{lemma:monster_pure}}\\
{}= \mcons\,(m_f \alift{\pappl} (\apure_M\,\langle a, \apure_{\stream{M}}\,a\rangle))
  & \mbox{by definition of }\appl\\
{}= \mcons\,((\apure_M\,(\pappl)) \appl m_f \appl (\apure_M\,\langle a, \apure_{\stream{M}}\,a\rangle))
  & \mbox{by definition of }\alift{-}\\
{}= \mcons\,(m_f \bind \lambda \langle f,\sigma_f\rangle. \return\,(\langle f,\sigma_f\rangle \pappl \langle a, \apure_{\stream{M}}\,a\rangle))
  & \mbox{by Lemma \ref{lemma:pure_app_pure_bind}} \\
{}= \mcons\,(m_f \bind \lambda \langle f,\sigma_f\rangle. \return\,(\langle f\,a,\sigma_f \appl \apure_{\stream{M}}\,a\rangle))
  & \mbox{by definition of }\pappl \\
{}= \mcons\,(m_f \bind \lambda \langle f,\sigma_f\rangle. \return\,(\langle f\,a,(\apure_{\stream{M}}\,(\lambda f. f\,a)) \appl \sigma_f\rangle))
  & \mbox{by coinduction hypothesis} \\
{}= \mcons\,(m_f \bind \lambda \langle f,\sigma_f\rangle. \return\,
       (\langle \lambda f. f\,a, \apure_{\stream{M}} (\lambda f. f\,a) \rangle \pappl \langle f,\sigma_f \rangle)
  & \mbox{by definition of }\pappl \\
{}= \mcons\,(m_f \bind \return\comp
       (\langle \lambda f. f\,a, \apure_{\stream{M}} (\lambda f. f\,a) \rangle \pappl {})
  & \mbox{by definition of composition}\\
{}= \mcons\,((\apure_M\,(\langle \lambda f. f\,a, \apure_{\stream{M}}\,(\lambda f. f\,a)  \rangle\pappl{})) \appl m_f)
  & \mbox{by Lemma \ref{lemma:pure_app_bind}}\\
{}= \mcons\,((\apure_M\,(\pappl)) \appl (\apure_M\,\langle \lambda f. f\,a, \apure_{\stream{M}}\,(\lambda f. f\,a)  \rangle) \appl m_f)
  & \mbox{by the homomorphism law for }M \\
{}= \mcons\,((\apure_M\,\langle \lambda f. f\,a, \apure_{\stream{M}}\,(\lambda f. f\,a)  \rangle) \alift{\pappl} m_f)
  & \mbox{by definition of }\alift{-}\\
{}= (\mcons\,(\apure_M\,\langle \lambda f. f\,a, \apure_{\stream{M}}\,(\lambda f. f\,a)  \rangle)) \appl (\mcons\,m_f)
  & \mbox{by definition of }\appl \\
{}= (\apure_{\stream{M}}\,(\lambda f. f\,a)) \appl (\mcons\,m_f)
  & \mbox{by Lemma \ref{lemma:monster_pure}} \\
{} = (\apure_{\stream{M}}\,(\lambda f. f\,a)) \appl \sigma_f
\end{array}
$$
\end{proof}


% Attempt at lemma 8 using only applicative constraint (or variation)

\begin{definition}
Assuming $M$ is an applicative, with $f : A \rightarrow B$, $m_a : M\, A$ and $b : B$, 
a \emph{flippable} applicative is one such that the following holds:
$$
\apure_M\, f \appl m_a \appl (\apure_M\, b) = \apure_M\, (\lambda b. \lambda a. f\, a\, b) \appl (\apure_M\, b) \appl m_a
$$
\end{definition}

\begin{lemma}
If the base functor $M$ is a flippable applicative, then monsters satisfy the applicative interchange law:
$$
\sigma_f \appl (\apure_{\stream{M}}\,a) = (\apure_{\stream{M}}\,(\lambda f. f\,a)) \appl \sigma_f
$$
\end{lemma}
\begin{proof}
$$
\begin{array}{ll}
\sigma_f \appl (\apure_{\stream{M}}\,a) = (\mcons\,m_f) \appl (\apure_{\stream{M}}\,a) \\
{}= (\mcons\,m_f) \appl (\mcons\,(\apure_M\,\langle a, \apure_{\stream{M}}\,a\rangle))
  & \mbox{by Lemma \ref{lemma:monster_pure}}\\
{}= \mcons\,(m_f \alift{\pappl} (\apure_M\,\langle a, \apure_{\stream{M}}\,a\rangle))
  & \mbox{by definition of }\appl\\
{}= \mcons\,((\apure_M\,(\pappl)) \appl m_f \appl (\apure_M\,\langle a, \apure_{\stream{M}}\,a\rangle))
  & \mbox{by definition of }\alift{-}\\
{}= \mcons\,((\apure_M\,(\lambda q . \lambda p . p \pappl q)) \appl (\apure_M\,\langle a, \apure_{\stream{M}}\,a\rangle) \appl m_f)
  & \mbox{by flippable applicative property}\\
{}= \mcons\,((\apure_M\,(\lambda p . p \pappl \pair{a}{\apure_{\stream{M}}\,a})) \appl m_f)
  & \mbox{by homomorphism law for }M\\
{}= \mcons\,((\apure_M\,(\lambda \pair{f}{\phi} . \pair{f}{\phi} \pappl \pair{a}{\apure_{\stream{M}}\,a})) \appl m_f)
  & \mbox{observing the required type of }p\\
{}= \mcons\,((\apure_M\,(\lambda \pair{f}{\phi} . \pair{f a}{\phi \appl (\apure_{\stream{M}}\,a)})) \appl m_f)
  & \mbox{by definition of } \pappl \\
{}= \mcons\,((\apure_M\,(\lambda \pair{f}{\phi} . \pair{f a}{(\apure_{\stream{M}}\,(\lambda f . f\, a)) \appl \phi})) \appl m_f)
  & \mbox{by coinduction hypothesis} \\
{}= \mcons\,((\apure_M\,(\pair{(\lambda f . f\, a)}{\apure_{\stream{M}}\,(\lambda f . f\, a)}\, \pappl )) \appl m_f)
  & \mbox{by definition of } \pappl \\
{}= \mcons\,((\apure_M\,(\pappl)) \appl (\apure_M\,\langle \lambda f. f\,a, \apure_{\stream{M}}\,(\lambda f. f\,a)  \rangle) \appl m_f)
  & \mbox{by the homomorphism law for }M \\
{}= \mcons\,((\apure_M\,\langle \lambda f. f\,a, \apure_{\stream{M}}\,(\lambda f. f\,a)  \rangle) \alift{\pappl} m_f)
  & \mbox{by definition of }\alift{-}\\
{}= (\mcons\,(\apure_M\,\langle \lambda f. f\,a, \apure_{\stream{M}}\,(\lambda f. f\,a)  \rangle)) \appl (\mcons\,m_f)
  & \mbox{by definition of }\appl \\
{}= (\apure_{\stream{M}}\,(\lambda f. f\,a)) \appl (\mcons\,m_f)
  & \mbox{by Lemma \ref{lemma:monster_pure}} \\
{} = (\apure_{\stream{M}}\,(\lambda f. f\,a)) \appl \sigma_f

\end{array}
$$
\end{proof}


