\documentclass{jfp}

\usepackage{listings}
\usepackage{notations}


\begin{document}

\journaltitle{JFP}
\cpr{Cambridge University Press}
\doival{10.1017/xxxxx}

\lefttitle{\LaTeX\ Supplement}
\righttitle{Journal of Functional Programming}

\totalpg{\pageref{lastpage01}}
\jnlDoiYr{2021}

\title{Programming with Monsters}

\begin{authgrp}
\author{Venanzio Capretta}
\affiliation{University of Nottingham\\
        (\email{venanzio.capretta@nottingham.ac.uk})}
\author{Christopher Purdy}
\affiliation{University of Nottingham\\
        (\email{psycjpu@exmail.nottingham.ac.uk})}
\end{authgrp}

\begin{abstract}
This is an article about monadic streams.
\end{abstract}

\maketitle

\section{Introduction}

{\em Monadic streams} (which we shortly call {\em monsters}) are infinite sequences of values where each value and the sub-sequence following it are produced by the execution of a monadic action.

To understand monadic streams, we must first look at pure streams.
A \emph{pure stream} is an infinite sequence of values, for example (using the Haskell notation that we will introduce later), the stream of all natural numbers:
\begin{haskell}
  nats = 0 <: 1 <: 2 <: 3 <: 4 <: (*...*)
\end{haskell}
The type of pure streams with elements of type \hcode{a} is denoted by \hcode{Stream a}. The cons operation \hcode{(<:)} is used to append an element in front of an existing stream. Streams are infinite, so we must use recursion to define them:
\begin{haskell}
nats :: Stream Int
nats = natsFrom 0 where
  natsFrom n = n <: natsFrom (n+1)
\end{haskell}

Pure streams are generated by Haskell functions.
Their values cannot depend on interaction with the user, or on a hidden state, or other computational effects.
Monsters are an abstract definition of streams with effects.
We provide a library of operations on them, some generalizing similar operations of pure streams or lists, some specific to our abstract setting.

In Haskell, computational effects are modeled by the {\em monad} type class.
A type constructor \hcode{M} is a monad if it provides certain methods and satisfies certain equalitites.
The type of monadic streams of elements of type \hcode{a} based on the monad \hcode{M} will be written \hcode{MonStr M a}.

Let's look at a simple example of an IO-monster, where the action is an input-output interaction: we want to generate a sequence of input numbers supplied by the user.
Let \hcode{inputInt} be a single action that ask the user for a value.
Then our library provides a \hcode{repeat} function to iterate it an indefinite number of times:
\begin{haskell}
inputInt :: IO Int
inputInt = do
  putStr "Write a number: "
  fmap read getLine

inputInts :: MonStr IO Int
inputInts = M.repeat inputInt
\end{haskell}

Let's show how an IO-monster can be used in a simple guessing game:
The user must guess a number; they can try as many times as they want; at every failed attempt, they are told whether the number is too small or too big.
The sequence of guesses is given by an IO-monster \hcode{s}:
\begin{haskell}
guessNum :: Int -> MonStr IO Int -> IO ()
guessNum x s = do
  putStrLn "Guess the number"
  (y,s') <- uncons s
  putStr (show y ++ " is ")
  if y == x
    then putStrLn "correct" >> return ()
    else putStrLn (if y < x then "too small" else "too big") >> guessNum x s'
\end{haskell}

Now given a number \hcode{x} (maybe randomly generated), we can get the user to play the guessing game by running \hcode{guessNum x inputInts}.
Here's the transcription of an execution \hcode{guessNum 42 inputInts}:
\begin{verbatim}
Guess the number
Write a number: 50
50 is too big
Guess the number
Write a number: 30
30 is too small
Guess the number
Write a number: 40
40 is too small
Guess the number
Write a number: 45
45 is too big
Guess the number
Write a number: 42
42 is correct
\end{verbatim}

The monster \hcode{inputInts} is not the only member of \hcode{MonStr IO Int}.
In fact, the stream \hcode{nats} defined at the start is also an IO-monster (it is polymorphic in the monad).
If we run \hcode{guessNum 42 inputInts} we obtain:
\begin{verbatim}
Guess the number
0 is too small
Guess the number
1 is too small
Guess the number
2 is too small
Guess the number
3 is too small

...

Guess the number
40 is too small
Guess the number
41 is too small
Guess the number
42 is correct
\end{verbatim}

\section{Definition of Monsters}

\section{Comparison with Standard Data Types}

\section{Type Classes}

\section{Applications}

\section{Conclusions}

\label{lastpage01}

\end{document}
