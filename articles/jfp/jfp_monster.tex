\documentclass{jfp}

\usepackage{listings}
\usepackage{notations}


\begin{document}

\journaltitle{JFP}
\cpr{Cambridge University Press}
\doival{10.1017/xxxxx}

\lefttitle{\LaTeX\ Supplement}
\righttitle{Journal of Functional Programming}

\totalpg{\pageref{lastpage01}}
\jnlDoiYr{2021}

\title{Programming with Monsters}

\begin{authgrp}
\author{Venanzio Capretta}
\affiliation{University of Nottingham\\
        (\email{venanzio.capretta@nottingham.ac.uk})}
\author{Christopher Purdy}
\affiliation{University of Nottingham\\
        (\email{psycjpu@exmail.nottingham.ac.uk})}
\end{authgrp}

\begin{abstract}
This is an article about monadic streams.
\end{abstract}

\maketitle

\section{Introduction}

{\em Monadic streams} (which we shortly call {\em monsters}) are infinite sequences of values where each value and the sub-sequence following it are produced by the execution of a monadic action.

To understand monadic streams, we must first look at pure streams.
A \emph{pure stream} is an infinite sequence of values, for example (using the Haskell notation that we will introduce later), the stream of all natural numbers:
\begin{haskell}
  nats = 0 <: 1 <: 2 <: 3 <: 4 <: (*...*)
\end{haskell}
The type of pure streams with elements of type \hcode{a} is denoted by \hcode{Stream a}. The cons operation \hcode{(<:)} is used to append an element in front of an existing stream. Streams are infinite, so we must use recursion to define them:
\begin{haskell}
nats :: Stream Int
nats = natsFrom 0 where
  natsFrom n = n <: natsFrom (n+1)
\end{haskell}

\section{Definition of Monsters}

\section{Comparison with Standard Data Types}

\section{Type Classes}

\section{Applications}

\section{Conclusions}

\label{lastpage01}

\end{document}
