\section{Introduction}

A monadic stream is a sequence of values in which every element is obtained by triggering a monadic action.
If $\sigma$ is such a stream, it will consist of an action for a certain monad $M$ that, when executed, will return a head (first element) and a tail (continuation of the stream).
This process can be continued in a non-well-founded way: streams constitute a coinductive type.

Formally the type of streams over a monad $M$ (let's call them {\em $M$-monsters}) with elements of type $A$ is defined, with an Agda-like notation \cite{agda}, as:

$$
\begin{array}[t]{l}
\codata\;
\stream{M,A}:\set\\
\quad \mcons_M: M\,(A\times \stream{M,A})\rightarrow\stream{M,A}
\end{array}
$$

Categorically, we can see this type as the {\em final coalgebra} of the functor $F_M\,X = M\,(A\times X)$.
The final coalgebra does not necessarily exist for every $M$, 
but it does for most of the commonly used monads, specifically for those that are container functors \cite{AAG:2005}.

The definition of $M$-monsters is very close to that of {\em cofree (or iterative) comonad}, which can be seen as the type of $M$-monsters with a pure 
leading value \cite{AAMV:2003,CUV:2006}.

The monadic streams definition is a type operator that maps a type $A$ to the type of $M$-monsters with elements of type $A$; we may indicate the operator by $\stream{M}$ and the type by the slightly different notation $(\stream{M}\,A)$.
This notation will be useful when we prove properties of the operator, for example that it is an applicative functor.

Instantiating $M$ with some of the most well-known monads leads to versions of known data types or to interesting new constructs.

If we instantiate $M$ with the identity monad, we obtain the type of pure streams.
Its usual definition is the following:

$$
\begin{array}[t]{l}
\codata\;
\stream{A}:\set\\
\quad (\scons): \nat\rightarrow \stream{\nat} \rightarrow\stream{\nat}.
\end{array}
$$

An element of $\stream{A}$ is an infinite sequence of elements of $A$: $a_0 \scons a_1\scons a_2\scons \cdots$.




If we instantiate $M$ with the $\maybe$ monad we obtain the type $\stream{\maybe,A}$, equivalent to the type of lazy lists $\lst{A}$.
The $\maybe$ monad is a functor that adds an extra element to the argument type:
$\maybe\,X$ contains copies of each element $x:X$, denoted by $\just\,x$, plus a {\em empty} element $\nothing$.
So $\maybe\,X \cong X+1$.
The single constructor $\mcons_\maybe: \maybe\,(A\times \stream{\maybe,A})\rightarrow\stream{\maybe,A}$ is equivalent to two constructors (for $\nothing$ and $\just$):

$$
\begin{array}[t]{l}
\codata\;
\lst{A}:\set\\
\quad (\scons): A\times \lst{A}\rightarrow\lst{A}\\
\quad \nil: \lst{A}.
\end{array}
$$

This means that an element of $\lst{A}$ is either an empty sequence $\nil$ or a non-empty sequence $a\scons \sigma$ where $a:A$ and $\sigma$ is recursively an element of $\lst{A}$.
Since this is a coinductive type, the constructor $(\scons)$ can be applied an infinite number of times.
Therefore $\lst{A}$ is the type of finite and infinite sequences.

Another example is when the underlying monad is $M = \lstsym $ itself.
In this case each entry in the stream is a list of pairs of heads and tails.
This is equivalent to trees of arbitrary branching degrees (finite branches if we use only finite lists, but also countably infinite branches if we use lazy lists).
Since the type is coinductive, the trees can be non-well-founded, that is, they may be infinitely deep.

If we choose $M$ to be the {\em state transformer} monad, $M$-monsters are state machines that, at every step, produce an output value that depends on an underlying state and change the state itself.
The state transformer monad is defined as $\state_S\,A = S\rightarrow A\times S$, where $S$ is the type of underlying states.
We use the notation $\stmon{S}\,A = \stream{\state_S}\,A$ to denote state monsters.
They will be useful to construct the counterexample to the monad laws in Section \ref{sec:monad}.

Finally, in Haskell user interaction and other system effects are encapsulated in the $\io$ monad. An $\io$ action produces a value that possibly depends and triggers effects. $\io$-monsters are interactive processes that continuously interface with the external world.

A companion paper that we will publish later will present the Haskell monster library that we developed and describe several of its applications.

It is important to make two observations about the underlying ``monad'' $M$.

First, $M$ does not need to be a monad for the definition to make sense. 
In fact we will obtain several interesting results when $M$ satisfies weaker conditions, for example being an applicative functor.
So we will take $M$ to be any type operator (but see second observation) and we will explicitly state what properties we assume about it.
The most important instances are monads and it is convenient to use the facilities of monadic notation in programming and monad theory in reasoning.

The second observation is that it is not guaranteed in general that the $\codata$ type is well-defined.
Haskell will accept the definition when $M$ is any operator, but mathematically the type is well defined only when $F_M\,X = M\,(A\times X)$ is a functor with a final coalgebra.
As stated above, this is the case if $M$ is a container functor and we assume that it is for the rest of the article.

Functions with $M$-monsters as codomain can be defined by explicitely giving a coalgebra.
In practical programming it is more convenient to define function by {\em corecursive equations} that satisfy the property of {\em guardedness by constructors}:
a corecursive equations is accepted if the right-hand side is a term with a constructor on top and recursive calls occurring only as direct arguments of that constructor.

As an example, here is a function that generates a state machine from a natural number:

$$
\begin{array}{l}
\fromstepstr : \nat \rightarrow \stmon{\nat}\,\nat \\
\fromstepstr\, n = \mcons\, (\lambda s. \pair{\pair{s}{\fromstepstr\, (n + 1)}}{s + n})
\end{array}
$$

Given an input $n$, this defines a state-monster that reads the current state $s$, returns its value as output, updates the state to $s+n$, and continues recursively by calling itself on input $n+1$.
In the end it will produce the infinte sequence $s \scons s+n \scons s+n+1 \scons s+n+2 \scons \cdots$.
The justification of the soundness of the definition is in the fact that the recursive call $\fromstepstr\, (n + 1)$ occurs under the guard of the constructor $\mcons $ and is used to generate the recursive sub-stream of the main output value.
The fact that the input $n+1$ is larger than the original input $n$ is irrelevant to corecursive definitions (contrary to what happens in inductive definitions): what matter is that the first element of the stream and the new state are produced before the call is executed.

Another example is the function from monsters to monsters that increases every element by one.
This is a function polymorphic on $M$ that only assumes that $M$ is a functor.

$$
\begin{array}{l}
\incr : \stream{M}\,\nat \rightarrow \stream{M}\,\nat\\
\incr\,(\mcons\,m) = \mcons\,(M\,(\lambda \pair{n}{\sigma}. \pair{n+1}{\incr\,\sigma})\,m)
\end{array}
$$

Here the pattern-matching variable $m$ has type $M\,(\nat\times \stream{M}\,\nat)$.
We map onto it the function that increases the output value by one and recursively applies $\incr$ to the tail.
This recursive occurrence is justified because it is guarded by $\mcons$ and mapped to the direct subterms inside the monad action.
By the way,
after we prove that $\stream{M}$ is a functor whenever $M$ is in Section \ref{sec:functor}, and that it is applicative whenever $M$ is in Section \ref{sec:applicative},
the definition can be simplified and made more intuitive in the following ways, respectively:
$$
\incr\,\sigma = \stream{M}\,(+1)\,\sigma
\qquad
\incr\,\sigma = \apure\,(+1) \appl \sigma
$$


See previous survey work \cite{capretta:2011} for an overview of the theory of final coalgebras, coinductive types, and corecursive definitions.
