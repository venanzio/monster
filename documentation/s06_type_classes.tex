\section{Instances of Functor, Applicative, Monad}

Show that monadic streams are an instance of these three classes, under some assumptions about the underlying monad.

So far we determined that we think that MonStr satisfies the monad laws if the underlying monad is commutative and idempotent \cite{idempotent_monads}. (Proof?)

What about Applicative?

Give conterexamples where it isn't a monad (using State).

Also examples when it is a monad even if the underlying monad is not commutative and idempotent: with List as underlying monad we obtain Trees, which are a monad. Can this be generalized.

This section outlines the Functor, Applicative, and Comonad instances, proving that the functions defined on monadic streams to implement these satisfy the relevant laws. We will prove these with a mixture of equational reasoning (using Haskell), and categorical reasoning.

\subsection{Functor Instance}

To show that $\stream{M}$ is a functor whenever $M$ is, we have to define its behaviour on morphisms: if $f:A\rightarrow B$, then we must define how $f$ maps on monadic streams:
$$
\begin{array}{l}
\stream{M}\,f : \stream{M,A} \rightarrow \stream{M,B}\\
\stream{M}\,f\,(\mcons\,m) = \mcons\,(M\,(f\times \stream{M}\,f)\,m)
\end{array}
$$

This definition complies with the {\em guarded-by-constructors} discipline: the recursive call to $(\stream{M}\,f)$ is mapped to the recursive substreams by the functorial application of the functor $M\,(A \times -)$.
That is: $(\stream{M}\,f)$ will be recursively applied only at the recursive positions inside the shape of $m$.
There are also applications of $f$ to the first element (of type $A$) of the pairs in the $M$-position: this is non-recursive, and therefore not problematic.

The Haskell version of the functorial mapping uses a general stream transformer at the top level: \hcode{unwrapMS} maps between \hcode{MonStr m a} and \hcode{MonStr m b} by mapping through $m$ a function on the components:

\begin{haskell}
unwrapMS :: MonStr m a -> m (a, MonStr m a)
unwrapMS (MCons m) = m

transformMS :: Functor m => (a -> MonStr m a -> (b, MonStr m b)) ->
                                  MonStr m a -> MonStr m b
transformMS f s = MCons $ fmap (\(h,t) -> f h t) (unwrapMS s)

instance Functor m => Functor (MonStr m) where
   -- fmap :: (a -> b) -> MonStr m a -> MonStr m b
   fmap f = transformMS (\a s -> (f a, fmap f s))
\end{haskell}

We can now prove that the functor laws are satisfied by $\stream{M}$.
\begin{lemma}\label{lemma:functor_id}
The identity functor law holds for monadic streams:
$$
\stream{M}\,\id_A = \id_{\stream{M,A}}
$$
\end{lemma}
\begin{proof}
We apply the left-hand side function to an $M$-monster in constructor form:
$$
\begin{array}{ll}
\stream{M}\,\id_A\,(\mcons\,m)\\
{}= \mcons\,(M\,(\id_A\times \stream{M}\,\id_A)\,m)
  & \mbox{by definition}\\
{}= \mcons\,(M\,(\id_A\times \id_{\stream{M,A}})\,m)
  & \mbox{by Coinduction Hypothesis}\\
{}= \mcons\,(M\,(\id_{A\times \stream{M,A}})\,m)
  & \mbox{by functoriality of }\times\\
{}= \mcons\,(\id_{M\,(A\times \stream{M,A})}\,m)
  & \mbox{by functoriality of }M\\
{}= \mcons\,m
\end{array}
$$
\end{proof}




\begin{lemma}\label{lemma:functor_comp}
The composition functor law holds for monadic streams:

If $f:A\rightarrow B$ and $g:B\rightarrow C$, then
$$
\stream{M}\,(g\comp f) = (\stream{M}\,g) \comp (\stream{M}\,f)
$$
\end{lemma}


\subsubsection{Functor proof}

Proof that \hcode{fmap id == id}

\begin{haskell}
fmap id = transformMS (\a s -> id a, fmap id s)
-- definition of `transformMS`
= \s -> MCons $ fmap (\(h,t) -> (\a s -> (id a, fmap id s)) h t) (unwrapMS s)
-- application of `(\a s -> (id a, fmap id s))` to `h t`
= \s -> MCons $ fmap (\(h,t) -> (id h, fmap id t)) (unwrapMS s)
-- take as assumption that `fmap id t == id t` - coinductive hypothesis?
= \s -> MCons $ fmap (\(h,t) -> (id h, id t)) (unwrapMS s)
-- definition of `id`
= \s -> MCons $ fmap (\(h,t) -> (h,t)) (unwrapMS s)
-- definition of `id`
= \s -> MCons $ fmap id (unwrapMS s)
-- `unwrapMS` returns an element in a functor, so `fmap id == id` in this case
= \s -> MCons $ id (unwrapMS s)
-- application of `id`
= \s -> MCons $ (unwrapMS s)
-- MCons and unwrapMS are inverses
= \s -> id s 
= id
\end{haskell}

Proof that \verb+fmap (f . g) == (fmap f) . (fmap g)+

To simplify notation in the proof, we introduce the notation \verb+tr(f)+ for the expression \verb+\(h,t) -> (f h, fmap f t)+.

We're going to use the fact that the underlying operator \verb+m+ is a functor and so satisfies the functor laws, and also that the pairing operator \verb+(,)+ is functorial in both arguments.

By definition of \verb+fmap+ for monsters, we have that
\begin{haskell}
fmap f s = transformMS (\ a s -> (f a, fmap f s)) s
         = MCons $ fmap (\ (h,t) -> (\a s -> (f a, fmap f s) h t)) (unwrapMS s)
         = MCons $ fmap (\ (h,t) -> (f h, fmap f t)) (unwrapMS s)
         = MCons $ fmap tr(f) (unwrapMS s)
\end{haskell}

We also use the fact that the monster constructor \verb+MCons+ and the function \verb+unwrapMS+ that removes it are inverse of each other.

\begin{haskell}
fmap (f . g) = transformMS (\a s -> (f . g) a, fmap (f . g) s)
-- definition of `transformMS`
= \s -> MCons $ fmap (\(h,t) -> (\a s -> ((f . g) a, fmap (f . g) s)) h t) (unwrapMS s)
-- application of `(\a s -> ((f . g) a, fmap (f . g) s))` to `h t`
= \s -> MCons $ fmap (\(h,t) -> ((f . g) h, fmap (f . g) t)) (unwrapMS s)`
-- take as assumption that `fmap (f . g) t == (fmap f . fmap g) t` - coinductive hypothesis?
= \s -> MCons $ fmap (\(h,t) -> ((f . g) h, (fmap f . fmap g) t)) (unwrapMS s)
-- By fuctoriality of pairing in both components
= \s -> MCons $ fmap (tr(f) . tr(g)) (unwrapMS s)
-- By functoriality of the underlying operator m
= \s -> MCons $ (fmap tr(f)) . (fmap tr(g)) (unwrapMS s)
-- MCons and unwrapMS are inverses
= \s -> MCons $ fmap tr(f)) $ unwrapMS $ MCons $ fmap tr(g) (unwrapMS s)
= \s -> MCons $ fmap tr(f)) $ unwrapMS $ fmap g s
= \s -> fmap f $ fmap g s
= fmap f . fmap g
\end{haskell}

\subsection{Applicative instance in Haskell}

\begin{haskell}
unwrapMS :: MonStr m a -> m (a, MonStr m a)
unwrapMS (MCons m) = m

transformMS :: Functor m => (a -> MonStr m a -> (b, MonStr m b)) ->
                                  MonStr m a -> MonStr m b
transformMS f s = MCons $ fmap (\(h,t) -> f h t) (unwrapMS s)

instance Functor m => Functor (MonStr m) where
   -- fmap :: (a -> b) -> MonStr m a -> MonStr m b
   fmap f = transformMS (\a s -> (f a, fmap f s))
\end{haskell}

\subsection{Comonad instance in Haskell}

\begin{haskell}
instance Comonad w => Comonad (MonStr w) where
  --extract :: MonStr w a -> a
  extract = extract . headMS
  
  --duplicate :: MonStr w a -> MonStr w (MonStr w a)
  duplicate s = MCons $ fmap (\(h,t) -> (s, duplicate t)) (unwrapMS s)
\end{haskell}

\verb+headMS+ returns the first element of the first pair in the monster, wrapped in the underlying functor. Since this functor is required to be a comonad, extract can be used to return the wrapped values inside.

We introduce \verb+mm(s)+ for the "monster matrix" formed by a monadic stream \verb+s+ - this is defined as a monster where the first element is \verb+s+, the second is the tail of \verb+s+, the third is the tail of the tail of \verb+s+, and so on.

The \verb+duplicate+ instance for monadic streams forms this "monster matrix": \verb+duplicate s = mm(s)+

\subsubsection{Comonad law proofs}

Proof that \verb+extract . duplicate == id+

\begin{haskell}
extract . duplicate 
= \ms -> extract (MCons $ fmap (\(h,t) -> (ms, duplicate t)) 
	(unwrapMS ms))
= \ms -> extract (headMS (MCons $ fmap (\(h,t) -> (ms, duplicate t)) 
	(unwrapMS ms)))
= \ms -> ms 
= id
\end{haskell}

Proof that \verb+fmap extract . duplicate == id+

\begin{haskell}
fmap extract . duplicate = \ms -> fmap extract (MCons $ fmap (\(h,t) -> 
	(ms, duplicate t)) (unwrapMS ms))
= \ms -> transformMS (\a s -> (extract a, fmap extract s)) (MCons $ 
	fmap (\(h,t) -> (ms, duplicate t)) (unwrapMS ms))
  [transformMS definition]
= \ms -> MCons $ fmap (\(h,t) -> (extract h, fmap extract t)) 
	(fmap (\(h,t) -> (ms, duplicate t)) (unwrapMS ms)) 
= \ms -> MCons $ fmap (\(h,t) -> (extract ms, fmap extract (duplicate t))) 
	(unwrapMS ms)
  [coinductive hypothesis]
= \ms -> MCons $ fmap (\(h,t) -> ((extract . headMS) ms, id t)) (unwrapMS ms)
  [(extract . headMS) ms = a, first element of ms]
= \ms -> MCons $ fmap (\(h,t) -> (a, id t)) (unwrapMS ms)
  [a is defined as the first element of ms, so h = a under the fmap]
= \ms -> ms
= id
\end{haskell}

Proof that \verb+duplicate . duplicate == fmap duplicate . duplicate+

\begin{haskell}
duplicate . duplicate = \ms -> duplicate (duplicate ms)
= \ms -> MCons $ fmap (\(h,t) -> (duplicate ms, duplicate t)) $
	(fmap (\(h,t) -> (ms, duplicate t)) (unwrapMS ms))
= \ms -> MCons $ fmap ((\(h,t) -> (duplicate ms, duplicate (duplicate t))) 
	(unwrapMS ms)
                      
fmap duplicate . duplicate = \ms -> fmap duplicate (MCons $ fmap (\(h,t) -> 
	(ms, duplicate t)) (unwrapMS ms))
= \ms -> transformMS (\a s -> (duplicate a, fmap duplicate s)) $
	(MCons $ fmap (\(h,t) -> (ms, duplicate t)) (unwrapMS ms))
= \ms -> MCons $ fmap (\(h,t) -> (\a s -> 
	(duplicate a, fmap duplicate s)) h t) (unwrapMS (MCons $ fmap (\(h,t) -> 
	(ms, duplicate t)) (unwrapMS ms)))
= \ms -> MCons $ fmap (\(h,t) -> (duplicate h, fmap duplicate t)) $ 
	(fmap (\(h,t) -> (ms, duplicate t)) (unwrapMS ms))
= \ms -> MCons $ fmap (\(h,t) -> 
	(duplicate ms, fmap duplicate (duplicate t))) (unwrapMS ms)
  [coinductive hypothesis]
= \ms -> MCons $ fmap ((\(h,t) -> 
	(duplicate ms, duplicate (duplicate t))) (unwrapMS ms)
= duplicate . duplicate
\end{haskell}


%\section{Monad proof}
%\input{monster_article_monad_proof}

\subsection{Monad Counter-example}

It's natural to ask, given the chosen name for this data structure, whether monsters themselves are monads, at least when the underlying functor is a monad. This is also a natural question because pure streams (with no functor guarding the elements) are monads. However, it turns out not to be the case in general, and we suspect that more constraints need to be placed on the underlying monad for the monster itself to be a monad. Namely, we believe the underlying monad should be idempotent. \\

An example of why monadic streams aren't monads in general uses State-monsters. The one defined here, when run, generates the stream of integers where the first two differ by $n$, the next two differ by $n+1$, and so on:
\begin{haskell}
fromStep :: Int -> FBMachine Int Int
fromStep n = MCons (state (\x -> ((x, fromStep (n+1)), x+n)))
\end{haskell}
\verb+FBMachine (Int,Int)+ is shorthand for \verb+MonStr (State (Int, Int))+, standing for 'feedback machine' (the meaning is explained in the examples).

For monadic streams to be a monad, we have to be able to join, or flatten, a monster of monsters into a single monster, with respect to certain laws - this is done in Haskell using a function \verb+>>=+, pronounced 'bind'. We also need a function \verb+return+ which injects a pure value into a monster.

The only return operation that makes sense is to apply the return of the underlying monad, and then repeatedly nest this inside itself (the same as \verb+pure+ from the Applicative instance):
\begin{haskell}
return :: Monad m => a -> MonStr m a
return a = MCons $ fmap (\a -> (a, return a) (return a)
\end{haskell}
Bear in mind that the rightmost \verb+return a+ is of type \texttt{a $\to$ m a}, and the one nested inside the tuple is of type \texttt{Monad m $\Rightarrow$ a $\to$ MonStr m a}. \\

One of the monad laws any monad needs to obey is the left identity law, which states: 
\begin{haskell}
f :: a -> MonStr m b
a :: a
return a  >>=  f == f a
\end{haskell}
In Haskell this laws is defined in terms of the bind (\verb+>>=+) operation, but is equivalent to left identity law in the Kleisli category of a monad.

Another monad law that bind has to obey is the right identity:
\begin{haskell}
ma :: MonStr m a
ma  >>= return == ma
\end{haskell}

We use the fact that bind is defined in terms of join:
\begin{haskell}
(>>= f) = join . fmap f 
\end{haskell}
The \verb+join+ function in this case is of type \texttt{MonStr m (MonStr m a) $\to$ MonStr m a}, which can be thought of as flattening a monster of monsters down into a single monster. \\

To show that monsters are not a monad, we reason that for any possible definition of join, there are counter-examples where it doesn't satisfy either the left or right identity laws.\\

Running \verb+fromStep 1+ with \verb+1+ produces the stream:
\begin{haskell}
runFBStr (fromStep 1) 1 = 1 <: 2 <: 4 <: 7 <: 11 <: (*...*)
\end{haskell}

This is the stream where, starting at $1$ for example, you add $1$ to get $2$, then add $2$ to get $4$, then add $3$ to get $7$, and so on. The fact that each step in the stream can be thought of as an action of 'adding some number' is pivotal to the upcoming reasoning.\\

\verb+return 1+ produces a monster where every element is $1$, polymorphic in the monad. \verb+return+ is the left and right unit for composition of Kleisli arrows (in any correctly defined monad), so we ignore any actions produced by it as they have no effect. \\

Since \verb+>>=+ is defined in terms of \verb+fmap+ and \verb+join+, we can start by looking just at \verb+fmap fromStep (return 1)+, and come back to joining the monster of monsters later.
\begin{haskell}
fmap fromStep (return 1) = (fromStep 1) <: (fromStep 1) <: (*...*)
\end{haskell}

Now, to join (flatten) this into a single stream, we need to somehow reconstruct \verb+fromStep 1+. There are three ways to do this, WLOG:

\subsection{Case 1}
We cannot take just the head of each stream, because the first action in each is 'adding $1$' - we would end up with a stream where $1$ is added to the previous element to get the next, which wasn't the definition of \verb+fromStep 1+. This could be thought of as taking the 'horizontal'. 

\subsection{Case 2}
The other naive method, which would work in this case, is to just take the first element of the stream, which \emph{is} \verb+fromStep 1+. We call this taking the 'vertical', which doesn't work in general as shown by another example:

Consider the pure stream \verb+from n+, defined as
\begin{haskell}
from :: Monad m => Int -> MonStr m a 
from n = n <: (from (n+1))
\end{haskell}

\verb+from 0+ gives the stream of natural numbers.
\begin{haskell}
from 0 = 0 <: 1 <: 2 <: (*...*)
\end{haskell}

We now look a the monster of monsters defined with this in mind:
\begin{haskell}
fmap return (from 0) = (return 0) <: (return 1) <: (return 2) <: (*...*)
\end{haskell}

Considering the right identity monad law, it is clear in this case that the join operation cannot be defined as taking the first element of the monster, since \verb+return 0+ $\neq$ \verb+from 0+.

\subsection{Case 3}

The only other way, considering the two examples, is to take the diagonal. This is because, in the first example:
\begin{haskell}
fmap fromStep (return 1) = (fromStep 1) <: (fromStep 1) <: (*...*)
\end{haskell}
we need the first action of the first stream (adding $1$), the second action of the second stream (adding $2$), and so on, to recreate  \verb+fromStep 1+.

However, to get the second action of the second stream (an 'adding $2$' action), we also need to traverse the \emph {first} action of the second stream (another 'adding $1$' action), since each element in a monadic stream is guarded by the previous. This would result in the net effect of 'adding $3$', which isn't what we need to reconstruct the second action of \verb+fromStep 1+. \\

Any other, more convoluted way of trying to get the action of 'adding $2$' falls under either, or a combination of, these three cases, which can be seen by reasoning with the examples given. This shows that you cannot make monadic streams a monad, with the assumption that the underlying functor is a monad.

One solution to this is to only allow the underlying monad to be idempotent. Taking the diagonal here would work fine, since with an idempotent monad, any order in which you join actions results in the same action. This is quite a strong constraint however, and it would be interesting if there is a weaker one.

