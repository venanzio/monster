\documentclass{article}
\usepackage{amsmath}
\usepackage{times}
\usepackage{booktabs}
\usepackage{listings}
\usepackage{grid-system}
\usepackage[document]{ragged2e}

\begin{document}
	
\section{Preliminary ideas}
	
\subsection{Definition of $ joinPrelimMS $}
	
The aim here is to find a way to manipulate the monadic actions in a monster matrix to find a join function such that the first and second monad laws are satisfied. The two cases below show how a monster matrix is produced in the case of each of these monad laws. This manipulation corresponds to the function $joinPrelimMS$ in MonStreams.hs.\\
\vspace{1cm}
1. fmap $f$ (return $a_0$)
\begin{center}
\begin{tabular}{c c c c c c c}
	     & $M_0 (a_0,$  &       &$M_0 (a_0,$  &       &$M_0 (a_0,$\\
	     & $M_1 (a_1,$  &       &$M_1 (a_1,$  &       &$M_1 (a_1,$\\
  $R_M ($& $M_2 (a_2,$  &$R_M ($&$M_2 (a_2,$  &$R_M ($&$M_2 (a_2,$ & $...$\\
		 & $M_3 (a_3,$  &       &$M_3 (a_3,$  &       &$M_3 (a_3,$\\
		 & $...$  &,       &$...$  &,       &$...$ &, \\
\end{tabular}
\end{center}
\vspace{1cm}
2. fmap return $ma$ (where $ma$ :: $MonStr$ $m$ $a$)
\begin{center}
\begin{tabular}{c c c c c c c}
	     & $R_M (a_0,$  &       &$R_M (a_1,$  &       &$R_M (a_2,$\\
	     & $R_M (a_0,$  &       &$R_M (a_1,$  &       &$R_M (a_2,$\\
  $M_0 ($& $R_M (a_0,$  &$M_1 ($&$R_M (a_1,$  &$M_2 ($&$R_M (a_2,$ & $...$\\
		 & $R_M (a_0,$  &       &$R_M (a_1,$  &       &$R_M (a_2,$\\
		 & $...$  &,       &$...$  &,       &$...$ &, \\
\end{tabular}
\end{center}

Now to start "joining" the inner and outer monsters. Taking the diagonal by joining monadic actions in the inner monster at each point in the outer monster gives:\\
\vspace{1cm}
1.
\begin{align*}
	R_M ( M_0 (a_0), R_M ( M^0_1 (a_1), R_M ( M^0_2 (a_2), ...\\
\end{align*}
2. 
\begin{align*}
	M_0 ( R_M (a_0), M_1 ( R_M (a_1), M_2 ( R_M (a_2), ...\\
\end{align*}
\\
where: 
\begin{itemize}
	\item{$M_x (a_x)$ denotes a monadic action in monad $M$ returning a value $a$, evaluated at position $x$ in its corresponding monadic stream}
	\item{$M^x_y (a_y)$ denotes the sequence of monadic actions $M_x ( M_{x+1} (... M_y ( a_y ) ... ) )$, returning the element at index $y$ in the corresponding monadic stream}
	\item{$R_M$ denotes the "do nothing" monadic action for monad $M$ - the monadic action produced by return of type $M (a)$}
\end{itemize}

\subsection{Going beyond the initial $ joinPrelimMS $}

This is an attempt to see whether you can manipulate the stream resutling from the previous function (in a different way to $ joinInnerMS $ in section 2) to preserve the first two monad laws. The third law isn't currently considered (since the first two are enough trouble at the moment).\\

Assuming $M$ satisfies the monad laws, you can join $R_M$ with any action $M (a)$ and produce $M (a)$, and this commutes (Kleisli composition forms). Using the notation above, joining $M^x_y (a)$ with $M_{y+1} (a)$ gives $M^x_{y+1} (a)$.\\

With these, you can "distribute" each monad across its head and tail using $headMS$ and $tailMS$, and then join the nested monadic actions produced by $tailMS$ (this is the function of $tailMMS$, equivalent to ($absorbMS$ . $tailMS$)). $fork\:(f,g)\:x$ produces the tuple $(f x, g x)$:\\
\vspace{1cm}
1.
\begin{align*}
	&fork (headMS,tailMMS) \;\$\; R_M ( M_0 (a_0), R_M ( M^0_1 (a_1), R_M ( ...\\
	&=\\
	&\bigg( R_M ( M_0 (a_0) ), R_M ( R_M ( M^0_1 (a_1), R_M ( ... \bigg)\\
	&=\\
	&\bigg( M_0 (a_0), R_M ( M^0_1 (a_1), R_M ( ... \bigg) \\\\
	&\text{calling this on the second element of the tuple and recursing gives the infinitely nested tuple:}\\\\
	&\bigg( M_0 (a_0), \bigg( M^0_1 (a_1), \bigg( M^0_2 (a_2) , \bigg( M^0_3 (a_3), ... \bigg)
\end{align*}
2. 
\begin{align*}
	&fork (headMS,tailMMS) \;\$\; M_0 ( R_M (a_0), M_1 ( R_M (a_1), M_2 ( ...\\
	&=\\
	&\bigg( M_0 ( R_M (a_0) ), M_0 ( M_1 ( R_M (a_1), M_2 ( ... \bigg)\\
	&=\\
	&\bigg( M_0 (a_0), M^0_1 ( R_M (a_1), M_2 ( ... \bigg) \\\\
	&\text{calling this on the second element of the tuple and recursing gives the infinitely nested tuple:}\\\\
	&\bigg( M_0 (a_0), \bigg( M^0_1 (a_1), \bigg( M^0_2 (a_2) , \bigg( M^0_3 (a_3), ... \bigg)
\end{align*}

Both of these apply the same sequence of monadic actions $M^0_x$ when you extract the element $a_x$.\\

If you take a monster of type $M (a)$, you can transform it in the same way to produce the same structure:

\begin{align*}
	&fork (headMS,tailMMS) \;\$\; M_0 ( a_0, M_1 ( a_1, M_2 ( ...\\
	&=\\
	&\bigg( M_0 (a_0), M_0 ( M_1 ( a_1, M_2 ( ... \bigg)\\
	&=\\
	&\bigg( M_0 (a_0), M^0_1 ( a_1, M_2 ( ... \bigg) \\\\
	&\text{recursively apply the same function on the second element of the tuple, and continue this:}\\\\
	&\bigg( M_0 (a_0), \bigg( M^0_1 (a_1), \bigg( M^0_2 (a_2) , \bigg( M^0_3 (a_3), ... \bigg)
\end{align*}

In this way, the "joining" procedure above produces a structure that is the same as the one produced by the distribution procedure on a valid monadic stream. If there was some way of "factoring" back out the monadic action, then this method of creating a join function would be possible, but this doesn't seem possible.\\ 

The "distributing" step duplicates the monadic action, so recombining the new head and tail would produce a monadic stream with a different behaviour (a different monster, meaning the monad laws wouldn't be satisfied).\\

In a sense though, the pseudo-monsters produced by this join procedure operate similarly to monadic streams - to retrieve the element $a_x$ in this nested tuple, you still need to execute monadic actions $M_0$ to $M_x$ (after applying $snd$ $x$ number of times to reach the nested tuple at layer $x$).\\

It seems that to finally produce a monadic stream from a monster matrix in the $Monad$ ($MonStr$ $m$) typeclass, the monad $ m $ used in the monadic stream needs to satify the property that joining two "equivalent" monadic actions should produce the same monadic action, for example:
\begin{itemize}
	\item $ Just $ ($ Just $ $ x $ ) == $ Just $ $ x $
\end{itemize}
However, counter-examples seem more common:
\begin{itemize}
	\item If you join a $ State $ computation which adds 1 to the state, with another one of the same, you produce a $ State $ computation which adds 2 to the state
	\item Joining two nested $ IO $ computations which ask the user for an input, produces an $ IO $ computation which asks the user for 2 inputs
\end{itemize}

\section{Cases for each law resulting from use of joinInnerMS}

Consecutive monadic actions returning a single element are written without parentheses to reduce clutter.\\

$ joinInnerMS $ is a function which, for a monster $MonStr\ m\ (m\ a)$, moves the tail at each level of the monster inside its monadic element. Basically transforms $M_0(M_a(a),M_1(...$ to $M_0(M_a(a, M_1(... $, by using fmap to insert the monadic stream tail inside the monad of the element (see the definition in MonStream.hs).

\subsection{Left identity}
$return\ a\ >>=\ f\ ==\ f\ a$

This case results in the follwing call to bind:\\
\begin{align*}
&(joinPrelimMS\ .\ joinInnerMS)\ \$\ fmap\ f\ (return\ a) \\
&=\\
&R_MM_0 ( a_0, R_MM_0M_1 (a_1, R_MM_0M_1M_2 (a_2, ...\\
&= &\text{[joining the monadic actions]}\\
&M_0 ( a_0, M^0_1 ( a_1, M^0_2 ( a_2, ... \\
\end{align*}

In contrast, $ f\ a $ where $ f\ ::\ (a\ â€“>\ MonStr\ m\ a) $ returns: $M_0 (a_0, M_1 (a_1, M_2 (a_2, ...$, so the two sides of the equation are not equal.\\
To see why imaging taking the second element of both streams:

 \begin{align*}
 & \big(M_0 ( a_0, M^0_1 ( a_1, M^0_2 ( a_2, ... \big)\ !!!\ 1 & \text{[$!!!$ is the indexing operator]}\\
 &=\\
 & M_0 (M^0_1 ( a_1 )) == M_0M_0M_1 ( a_1 )\\
 & \\
 & \big(M_0 (a_0, M_1 (a_1, M_2 (a_2, ... \big)\ !!! \ 1\\
 & =\\
 & M_0 (M_1 ( a_1 )) == M_0M_1 ( a_1 )
 \end{align*}
 
 As shown, the returned monadic action in the first instance has a duplication of $M_0$ - if this was a $State$ monadic action which modifies an existing state for example, this would change the behaviour of the monadic stream, potentially returning a different value for $ a_1 $ if the return value of the computation was dependant on the value of the state.

\subsection{Right identity}
$m\ >>=\ return\ ==\ m$

This case results in the follwing call to bind:\\
\begin{align*}
	&(joinPrelimMS\ .\ joinInnerMS)\ (fmap\ return\ m) \\
	&=\\
	&M_0R_M ( a_0, M_1R_MR_M (a_1, M_2R_MR_MR_M (a_2, ...\\
	&= &\text{[joining the monadic actions]}\\
	&M_0 ( a_0, M_1 ( a_1, M_2 ( a_2, ... \\
\end{align*}

This property seems to hold for any monad $M$ - only "seems" since it \textit{looks} like a valid monster is produced with the actions in the correct order, and experimenting with $ State $ and $ [\ ] $ monads seem to verify this assumption, but it hasn't been proven explcitly.

\section{Required properties of the inner monad}

This section looks specifically at the monster produced on the LHS of the left identity monad law, and compares it to the "clean" monster produced on the RHS. This is done by performing some operations and seeing if their behaviour is the same or different.\\

Looking at the left identity above, it seems like the monad used in a monster needs to satisfy the property that any "equivalent" monadic action performed twice will result in the same monadic action if they are joined.\\

In the case of taking the second element:
\begin{align*}
 & \big(M_0 ( a_0, M^0_1 ( a_1, M^0_2 ( a_2, ... \big)\ !!!\ 1\\
 &=\\
	& M_0M_0M_1 (a_1) = M_0M_1 (a_1)
\end{align*}

In the case of taking the third element:
\begin{align*}
& M_0M_0M_1M_0M_1M_2 (a_2) \\
=\ & M_0M_1M_0M_1M_2 (a_2) & \text{[join the top two actions]}\\
=\ & (M_0M_1)(M_0M_1)M_2 (a_2) & \text{[group equal "composite" actions]}\\
=\ & M_0M_1M_2 (a_2) & \text{[join the composite actions]}\\
\end{align*}

It is valid to group actions, since the assumed property states that the same two actions performed sequentially results in the same overall action (using join).

\subsection{Commutativity}

What if an arbitrary monadic action was inserted at an arbitrary depth in the monster? Does this produce the same behaviour on both of the above monsters?\\

I'm going to use the function:
\begin{lstlisting}
insertAct :: Monad m => Int -> m a -> MonStr m a -> MonStr m a
insertAct 0 ma mas = MCons . join $ (\(h,t) -> fmap (const (h,t)) ma) 
                                  <$> unwrapMS mas
insertAct n ma mas = MCons $ (\(h,t) -> (h, insertAct (n-1) ma t)) 
                                  <$> unwrapMS mas
\end{lstlisting}
to insert a new action. This can be used to insert a single monadic action at any level in the stream (discarding the new monadic actions result). My usage of it below assumes some arbitrary action $M_x$ and an insertion depth $n$ equal to 2, just to simplify notation.

\subsubsection{RHS "clean" monster}

For "clean" monsters (ones not produced in the monadic stream join operation)
\begin{align*}
& insertAct\ \$\ M_0(a_0, M_1(a_1, M_2 (a_2,... & \text{[inserting a monadic action $M_x$ ]}\\
=\ & M_0(a_0, M_1M_x(a_1, M_2 (a_2,... 
\end{align*}
Now take the nth element and you get the pile of monadic actions:
\begin{align*}
M_0M_1M_xM_2M_3M_4... (a_n)\\
\end{align*}
If $n = 2$:
\begin{align*}
M_0M_1M_xM_2 (a_2)\\
\end{align*}

\subsubsection{LHS monster produced by bind}

Now to do the same for one produced by the monadic stream created in joining the left identity:
\begin{align*}
& insertAct\ \$\ M_0(a_0, M^0_1(a_1, M^0_2 (a_2,... & \text{[inserting a monadic action $M_x$]}\\
=\ & M_0(a_0, M^0_1M_x(a_1, M^0_2 (a_2,... \\
\end{align*}

Now take the nth element, resulting in the sequence of actions (expanded for clarity):
\begin{align*}
& M_0M_0M_1M_xM_0M_1M_2M_0M_1M_2M_3... (a_n)
\end{align*}
If $n = 2$:
\begin{align*}
& M_0M_0M_1M_xM_0M_1M_2 (a_2)\\
=&\ M_0M_1M_xM_0M_1M_2 (a_2)
\end{align*}

Here we hit a problem - you can't combine the two groups of monadic actions $M_0M_1$ to reduce them using join, since they aren't next to eachother. This removes that reduction as an option to show the equality of the two monsters. \\

\subsubsection{Resolution}

For this to work, the monadic actions also need to be \textbf{commutative}, which would allow the following reduction:
\begin{align*}
& M_0M_1M_xM_0M_1M_2 (a_2)\\
=&\ (M_0M_1)M_x(M_0M_1)M_2 (a_2) &\text{[grouping actions]}\\
=&\ (M_0M_1)(M_0M_1)M_xM_2 (a_2) &\text{[applying commutativity]}\\
=&\ M_0M_1M_xM_2 (a_2)
\end{align*}

This results in the same monster as the "clean" RHS.\\

So far, it seems that in order for a monadic stream of a monad $M$ to itself be a monad, $M$ needs to have at least these properties:
\begin{itemize}
	\item Two monadic actions which perform the same action, should join to produce the same action - \textbf{idempotency}
	\item The order in which monadic actions are applied should be have no effect on the result - \textbf{commutativity} 
\end{itemize}

\subsubsection{Monads which may satisfy these properties}

https://dl.acm.org/doi/pdf/10.1145/1596550.1596553 - commutative monads:
\begin{itemize}
	\item Writer (with a commutative monoid)
	\item Identity
	\item Maybe
	\item Reader
	\item FiniteSet/Powerset
\end{itemize}

Clark and Wisbauer give a very in-depth categorical desciption of idempotent monads \cite{idempotent_monads}.

\bibliography{biblio.bib}
\bibliographystyle{abbrv}

\end{document}