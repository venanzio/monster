Laws:

1. return a >>= f  == f a
2. m >>= return    == m
3. (m >>= f) >>= g == m >>= (\x -> f x >>= g)


1.

return a = repeatMS a   [definition of return for MonStr - same as pure for applicative instance]
= a <: repeatMS a       [definition of repeatMS]
= pure a <:: repeatMS a 
= m(a) <:: repeatMS a
= (\s -> MCons (fmap (\a -> (a,s)) m(a))) (repeatMS a)
= MCons (fmap (\a -> (a,repeatMS a)) m(a))
= MCons m(a, repeatMS a)

return a = MCons m(a, repeatMS a)
... coinductive stuff
return a = MCons m(a, MCons m(a, MCons m(a, MCons m(a, ...

return a >>= f = joinMS (fmap f (return a))

Not sure whether destructors of MonStr (headMS and tailMS) can work together?



Motivation and explaination for Monad (MonStr m):
-------------------------------------------------
When you apply bind, you retain the original monadic actions, but for each element created a new stream is generated from that seed. The returned stream gives the stream of actions:

first action joined with the first action from the first inner stream, then the second action joined with the combination of the first and second actions from the second inner stream,

m_0o0i ( a_0, m_1o(0-1)i ( a_1, m_2o(0-2)i ( a_2, ...


Where m_Xo(0-Y)i means action X from the initial (outer) monadic stream, joined with the sequence of actions from the first (0th) up to the yth action in the inner monster generated by element a_Y

In effect, when you access element X in the resulting stream, you get the 
