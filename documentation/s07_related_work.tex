
\section{Related work and applications}

The general application of this library is hinted at in the examples section: data structures that can be represented as monadic streams (with the underlying functor being a monad) give meaningful semantics to the general operations we have developed.

Perhaps the most interesting correspondence is that of $\reader$-monsters and finite state transducers. In this context, the functions in our library provide a set of useful combinators to work with and define state machines. A few of these have been mentioned in sections 4 and 5, and some more uses are demonstrated in the attached example code.

\subsection{FRP application}

One further application of monadic streams is that they can be seen as a generalised form of Yampa's \cite{yampa_arcade} signal functions. This is expanded on by Perez et al. in \cite{frp_refactored}. For example, you can implement an integral signal function using the Reader monad. We use the same names as for the same constructs in Yampa, to make the correspondence clear:

\begin{haskell}
type DTime = Double

type SignalFunc a b = MonStr ((->) (DTime, a)) b
\end{haskell}

\begin{haskell}
integral :: SignalFunc Double Double
integral = MCons integralAuxF
                 
integralAuxF :: (DTime, Double) -> (Double, SignalFunc DTime Double)
integralAuxF (_, a) = (0 , integralAux 0 a)
   where integralAux igrl a_prev = MCons (\(dt, a') -> 
   		(igrl' dt, integralAux (igrl' dt) a'))
      where igrl' dt' = igrl + (dt' * a_prev)
\end{haskell}

Additionally, combinators defined in our library work similarly to combinators in Yampa. For example, their (internal) signal function composition combinator \verb+compPrim+ is conceptually the same as our function \verb+interleaveReadM+, which was covered in the $\io$ monad examples section.

Yampa's concept of signal functions is generalised further in Dunai, a library with more direct relationship to monadic streams.

\subsection{Relation to Dunai}

Dunai \cite{frp_refactored}\cite{dunai} is an FRP library implemented using monadic stream functions (MSFs), which Yampa has been implemented on top of (see BearRiver \cite{bearriver}). \\

The library we've developed in this article allows for a wide variety of operations on monadic streams. Since the MSFs used in Dunai are a special case of monsters (monsters with the underlying functor \verb+ReaderT a m+, where \verb+m+ is a monad), many functions in our library could be incorporated into Dunai, giving a set of potentially useful generalised transformations for MSF networks. \\

For example, \verb+scanM+ could be used to calculate a stream of intermediate velocity values from a stream of position values, by taking the difference of each consecutive position:
\begin{haskell}
positions :: SignalFunc Env Double 

speeds :: SignalFunc Env Double 
speeds = scanM (\a b -> b - a) positions
\end{haskell}

Here, \verb+Env+ is just a type representing some environment the signal function is operating on. \\

On the other hand, there are many interesting concepts in Dunai which could be incorporated into new functions in this library, such as their concept of FRP constructs. 

These encapsulate the idea of changing \verb+MonStr (ReaderT a (t m)) r+ where the underlying monad \verb+m+ is lifted with some monad transformer \verb+t+, into \newline \verb+MonStr (ReaderT a m) r+ where the monad transformer \verb+t+ was 'run' in some way, leaving only the monad \verb+m+. If the monad transformer were \verb+ListT+ for example, it would give rise to the concept of parallelism with broadcasting. 

Monad transformers were only briefly explored in the library, but this indicates that there may be many more constructs we can form when taking them into account. \\

Additionally, monadic streams could be a useful extension to MSF based FRP - as shown in \cite{frp_refactored}, monadic streams can already model an input stream of data into a reactive program. Using monadic streams instantiated with comonads, you could model input streams where the value of the input (and the rest of the stream) depends on some environment. 

Monadic streams where the underlying functor is a comonad can be seen as the progressing timeline of an environment under some iterated operation. The comonad provides the notion of environment, and the stream imbues it with a notion of its progression in time. This idea only encapsulates current and future values of the environment, with past states being discarded.

This could be useful to model systems which have some kind of self referential data store, or environments that can be used to modify themselves. \\

One possible barrier to using this in practice is that often inputs into a program, especially in FRP applications, are wrapped in some kind of $\io$ action. $\io$ is not comonadic, as there is no way to extract a pure value from it (without the use of \verb+unsafePerformIO+, but this is unsafe, as the name suggests). In that sense, monadic streams with comonads seem to have limited applicability when it comes to streams of context-dependent inputs, when those inputs come from outside of the program.


\subsection{Dataflow programming}

Another purpuse monadic streams with comonads could be used for is extending the comonadic approach to dataflow programming, developed in \cite{essence_of_dataflow}, with the context of other comonads. The idea is that any comonad \verb+w+ can be extended with the notion of past, present, and future values with \verb+MonStr w+. Functions out of the type \verb+MonStr m a+ are context-sensitive computations that are dependent on arbitrary numbers of future environments of type \verb+w a+.

\subsection{Properties of monadic streams}

Many properties of monadic stream functions have been proven in the appendix \cite{msf_properties} to BÃ¤renz, Perez, and Nilsson's 2016 paper on MSF based FRP \cite{frp_refactored}. Depending on their formulation, these proofs may also show that the same properties are true for monadic streams, because monadic streams are just MSFs that ignore their inputs. 

One of our goals is to investigate further how this work can be applied to the context of monadic streams.
