\section{Conclusions}

\begin{ccomment} 
	Further discussion of related literature and open problems is needed
\end{ccomment}

One glaring open problem is to prove that monadic streams are themselves monads when the underlying functor is an indempotent monad. We have almost proven this, and it seems to be the case experimentally, but a convincing proof is yet to be developed.\\

Future work on this library would include a review of the efficiency of many functions we defined - this project was initially an exercise to see what could be done with monadic streams, but if this library could be used for larger applications then efficiency could be an issue. 

Another angle of interest is to look further into exactly how monadic streams are different from the cofree comonad over a functor. The difference is only that there is no first 'unguarded' element in a monadic stream, but this is enough make them function entirely differently when instantiated with the same functors.

Finally, whether comonadic streams could have a role in functional reactive programming is still an open problem. It may also be interesting to look at a dual of Dunai's monadic stream functions \cite{dunai}. The dual of (co)monadic streams are monadic lists:
\begin{haskell}
data MonLst m a = m (Either a (MonLst m a)) 
\end{haskell}
Since the type of monadic stream functions is isomorphic to monadic streams with the reader monad transformer, the dual of monadic stream functions might be the following:
\begin{haskell}
data MSFDual w a = MonLst (EnvT w a)
\end{haskell}
which is essentially a nested tuple, with each layer after the first guarded with a comonad. Evaluating the comonad with \verb+extract+ or a co-Kleisli arrow will either result in a final tuple of type \verb+(e, a)+, or another layer of type \verb+(e, MonLst (EnvT w a))+. 

This is like an environment where values can be repeatedly extracted from, but at some point the environment will become exhausted, returning a single \verb+a+ instead of a new environment.
