\section{Conclusions}

This project developed a full library for monadic streams ({\em monsters}) in Haskell.

We generalized common operations, functions, applications from the standard $\lstsym$ library and libraries on pure streams to work on all monsters.
Applications of our work encompass not only a higher-order version of those libraries, but also new applications to non-well-founded trees, interactive processes, transition systems and automata, functional reactive programming, and more.

We proved several important abstract theorems about monsters and outlined strategies for further mathematical insights.
These proofs required original use of the technique of {\em coinduction}, which is a very recent and active area of research. \\

At this point in the project, a few new problems have come to light, some related to implementation details of the library, and some to the theory behind monadic streams and corresponding data structures. \\

Future work on this library will include a review of the efficiency of many functions we defined - this project was initially an exercise to see what could be done with monadic streams, but if this library could be used for larger applications then efficiency would be an issue. Also, whether all of the functions work exactly as intended is still uncertain. The functions that are analogous to those in \verb+Data.List+ have been tested, but we have not yet defined some concrete semantics to interpret all of the other functions with, meaning we can only be sure that their actions on monadic streams are approximately the intended ones. \\

We discovered, contrary to our initial assumptions, that monadic streams do not in general form a monad, even if the underlying functor does.
We investigated the causes of this shortcoming and we proposed a conjecture that
that monadic streams are themselves monads when the underlying functor is an idempotent monad \cite{idempotent_monads}. This seems evident from how the counter-example is constructed, and it seems to be the case experimentally, but a convincing proof showing that all of the monad laws hold has yet to be developed. 

Additionally, our proofs of the applicative and comonad laws need to be developed further, and the comonad proofs formalized. \\

Another angle of interest is to look further into exactly how monadic streams are different operationally from the cofree comonad over a functor. This is defined as the final coalgebra of $F_M\,X = A \times M\,X$, where $M$ is a functor, which is very similar to the definition of monadic streams in section 2.

The difference is only that there is no first `unguarded' element in a monadic stream, but this is enough make them function quite differently when instantiated with the same monads. \\

Finally, whether comonadic streams could have a good role in functional reactive programming is still an open problem. It may also be interesting to look at a dual of Dunai's monadic stream functions \cite{dunai}. The dual of (co)monadic streams are monadic lists:
\begin{haskell}
data MonLst m a = m (Either a (MonLst m a)) 
\end{haskell}
Since the type of monadic stream functions is isomorphic to monadic streams with the reader monad transformer, the dual of monadic stream functions might be the following:
\begin{haskell}
data MSFDual w e a = MonLst (EnvT e w) a
\end{haskell}
which is essentially a nested tuple, with each layer after the first guarded with a comonadic action. 

\begin{haskell}
data EnvT e w a = EnvT e (w a)
\end{haskell}

Evaluating the comonad with \verb+extract+ or a co-Kleisli arrow will either result in a final tuple of type \verb+(e, a)+, or another layer of type \verb+(e, MonLst (EnvT e w) a)+.

This is like an environment from which new values can be repeatedly extracted from, but at some point the environment will become exhausted, returning a single \verb+a+ instead of a new environment.

The purpose of investigating this is to see whether a monad-comonad interaction law \cite{uustalu:2019} between the underlying monad in a MSF and the underlying comonad in a \verb+MSFDual+ instance could be used to define a functor-functor interaction law between these two types, and whether this would have any novel uses or implications in the contexts we have discussed.
