\section{Conclusions}

\begin{ccomment} 
	A bit more discussion of related literature and maybe one more open problem is needed
\end{ccomment}

One glaring open problem is to prove that monadic streams are themselves monads when the underlying functor is an indempotent monad. We have almost proven this, and it seems to be the case experimentally, but a convincing proof is yet to be developed.\\

Future work on this library would include a review of the efficiency of many functions we defined - this project was initially an exercise to see what could be done with monadic streams, but if this library could be used for larger applications then efficiency could be an issue. Also, whether all of the functions work exactly as intended is still uncertain. The functions that are analogous to those in \verb+Data.List+ have been tested, but we have not yet developed concrete semantics to interpret all of the other functions with, meaning we can only be sure that their actions on monadic streams are approximately the intended ones.

Another angle of interest is to look further into exactly how monadic streams are different from the cofree comonad over a functor. The difference is only that there is no first 'unguarded' element in a monadic stream, but this is enough make them function entirely differently when instantiated with the same functors.

Finally, whether comonadic streams could have a role in functional reactive programming is still an open problem. It may also be interesting to look at a dual of Dunai's monadic stream functions \cite{dunai}. The dual of (co)monadic streams are monadic lists:
\begin{haskell}
data MonLst m a = m (Either a (MonLst m a)) 
\end{haskell}
Since the type of monadic stream functions is isomorphic to monadic streams with the reader monad transformer, the dual of monadic stream functions might be the following:
\begin{haskell}
data MSFDual w a = MonLst (EnvT w a)
\end{haskell}
which is essentially a nested tuple, with each layer after the first guarded with a comonad. Evaluating the comonad with \verb+extract+ or a co-Kleisli arrow will either result in a final tuple of type \verb+(e, a)+, or another layer of type \verb+(e, MonLst (EnvT w a))+. 

This is like an environment where values can be repeatedly extracted from, but at some point the environment will become exhausted, returning a single \verb+a+ instead of a new environment.
