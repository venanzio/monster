\section{Conclusions}

\begin{ccomment} 
	A bit more discussion of related literature and maybe one more open problem is needed
\end{ccomment}



One glaring open problem is to prove that monadic streams are themselves monads when the underlying functor is an indempotent monad. This seems evident from how the counter-example is constructed, and it seems to be the case experimentally, but a convincing proof showing that all of the monad laws hold has yet to be developed. \\

Future work on this library will include a review of the efficiency of many functions we defined - this project was initially an exercise to see what could be done with monadic streams, but if this library could be used for larger applications then efficiency would be an issue. Also, whether all of the functions work exactly as intended is still uncertain. The functions that are analogous to those in \verb+Data.List+ have been tested, but we have not yet defined some concrete semantics to interpret all of the other functions with, meaning we can only be sure that their actions on monadic streams are approximately the intended ones. \\

Another angle of interest is to look further into exactly how monadic streams are different operationally from the cofree comonad over a functor. The difference is only that there is no first 'unguarded' element in a monadic stream, but this is enough make them function quite differently when instantiated with the same monads. \\

Finally, whether comonadic streams could have a role in functional reactive programming is still an open problem. It may also be interesting to look at a dual of Dunai's monadic stream functions \cite{dunai}. The dual of (co)monadic streams are monadic lists:
\begin{haskell}
data MonLst m a = m (Either a (MonLst m a)) 
\end{haskell}
Since the type of monadic stream functions is isomorphic to monadic streams with the reader monad transformer, the dual of monadic stream functions might be the following:
\begin{haskell}
data MSFDual w e a = MonLst (EnvT e w) a
\end{haskell}
which is essentially a nested tuple, with each layer after the first guarded with a comonad. Evaluating the comonad with \verb+extract+ or a co-Kleisli arrow will either result in a final tuple of type \verb+(e, a)+, or another layer of type \verb+(e, MonLst (EnvT e w) a)+. 

This is like an environment from which new values can be repeatedly extracted from, but at some point the environment will become exhausted, returning a single \verb+a+ instead of a new environment.

The purpose of investigating this is to see whether a monad-comonad interaction law \cite{uustalu:2019} between the monad in a MSF and the comonad in the \verb+MSFDual+ type could be used to define a functor-functor interaction law between these two types, and whether this would have any novel uses or implications in the contexts we have discussed.