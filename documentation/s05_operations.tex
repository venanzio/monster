
 
\section{General functions and operations}

In light of the interpretations of various types of monadic stream, some of the general operations defined have interesting uses in all of some of the contexts presented. \\

Consider the \verb+dropM+ function. 

\begin{haskell}
dropM :: Monad m => Int -> MonStr m a -> MonStr m a
dropM n ms
  | n == 0    = ms
  | n > 0     = dropM (n - 1) (tailM ms)
  | otherwise = error "MonadicStreams.dropM: negative argument."
\end{haskell}

This drops the first $n$ elements of a monster. Doing so requires the joining of the first $n$ monadic actions, which in the case of State-monsters for example will keep the first $n$ state modifications. This is equivalent to ignoring the output of the feedback machine for its first $n$ feedbacks, so this operation could be seen as moving forwards in time $n$ steps. 

This 'moving forwards' interpretation is similar in every kind of monadic stream - in a List-monster, you get the list of choices after $n$ previous choices were made. In an IO-monster you get the output after the first $n$ computations. In a Reader-monster (state machine) you get the output and next state after giving the same input $n$ times. In a Maybe-monster (lazy list), you drop the first $n$ items from the list. \\

Another interesting function is \verb+scanM+. 

\begin{haskell}
scanA :: Applicative m => (a -> b -> a) -> a -> MonStr m b -> MonStr m a
scanA f z s = z <: scanH f z s
              where scanH f z s = MCons $ (\(a, s') -> 
              		(f z a, scanH f (f z a) s')) <$> uncons s
              
scanM :: Monad m => (a -> a -> a) -> MonStr m a -> MonStr m a
scanM f s = absorbM $ (\(a, s') -> scanA f a s') <$> uncons s
\end{haskell}

It combines each pair of elements in the stream together with a given function, resulting in a stream of the intermediate values. \verb+scanA+ also does this, but leaves an extra monadic action at the beginning of the stream, which \verb+scanM+ deals with by essentially removing it.

In the context of List-monads used as probability trees, \verb+scanM (*)+ will (when applied to a tree), return the tree of sequential probabilities. That is, given two consecutive branches of the tree $l_1$ and $l_2$ (which represent probabilities), this scan instance calculates $l_1 * l_2$, the probability of traversing the first branch \emph{and then} the second. The scan carries this result forward, so over three sequential branches $l_1$, $l_2$ and $l_3$, the function would produce the probability $l_1 * l_2 * l_3$ at the third branch in the new tree. 

In the same way, \verb=scanM (+)= calculates the disjoint unions of probabilities across each combination of branches in the tree. \\

A final interesting function is \verb+interleave+. This lets you interleave the actions of two monadic streams. 

\begin{haskell}
interleave :: Functor m =>  MonStr m a -> MonStr m a -> MonStr m a
interleave mas mbs = transform (\h t -> (h, interleave mbs t)) mas
\end{haskell}

In the context of List-monsters again, this function lets you interleave choices - for two List-monsters $L_0$ and $L_1$, representing decision trees, interleaving them results in a tree $L_{0,1}$ where the first decision in $L_{0,1}$ is the first in $L_0$, the second decision is the first in $L_1$, and so on. This can describe situations where different kinds of choices need to be made cyclically. In IO-monsters, this function lets you interleave the actions of two process, effectively implementing a simple kind of user-level multithreading. 

In Reader-monsters and State-monsters, a variation of this function, \newline \verb+interleaveReadM+ is better in the context of state machines (this function is discussed in the IO monad portion of section 4). Here, this function lets you combine two state machines such that the state of the second depends on the outputs of the first. This could be extended so that both state machines are dependent on each other, which is left as an exercise to the reader. \\

The main aim of this library was to define general functions that operate on generic data structures (defined as monadic streams), such that the functions have interesting, or even novel, uses in the contexts presented by different monads or functors. We hope that the functions presented above, alongside the example in section 4, give readers a general sense of this.

