\documentclass{article}

\usepackage{amssymb,amsmath,amsthm}
\usepackage{listings}
\usepackage{pstricks,pst-node}
\usepackage{hyperref}

\usepackage{tikz}
\usetikzlibrary{trees}

\usepackage[utf8]{inputenc}
\usepackage[english]{babel}

\title{Programming with Monsters}
\author{Christopher Purdy and Venanzio Capretta}

\usepackage{notations}

\newtheorem{definition}{Definition}
\newtheorem{theorem}[definition]{Theorem}
\newtheorem{proposition}[definition]{Proposition}
\newtheorem{lemma}[definition]{Lemma}
\newtheorem{example}[definition]{Example}
\newtheorem{conjecture}[definition]{Conjecture}

%format 

\begin{document}
\bibliographystyle{abbrv}

\maketitle

\begin{abstract}
A monadic stream is a potentially infinite sequence of values in which a {\em monadic action} is triggered at each step before the generation of the next element.
Monadic actions are a wide class of side effects, modes of execution, evaluation paradigms; they are realized as functional {\em containers} inside which the unfolding of the stream takes place.
Examples of monadic actions are: executing some input/output interactions, cloning the process into several parallel computations, executing transformations on an underlying state, terminating the sequence.

We develop a library of definitions and universal combinators to program with monadic streams and we prove several mathematical results about their behaviour.

We define the type of Monadic Streams (MonStr), dependent on two arguments: the underlying monad (the kind of possible actions) and the type of elements of the sequence.
We use the following terminology: a monadic stream with underlying monad $M$ is called an $M$-monster.
The definition itself doesn't depend on the fact that the underlying operator is a monad.
We define it generally: some of the operators can be defined without any assumptions, some others only need the operator to be a Functor or Applicative Functor.
A different set of important combinators and theoretical results follow from the assumption that the operator is a Comonad rather than a Monad.

We instantiate the abstract MonStr type with several common monads ($\maybe$, $\lstsym$, $\reader$, $\state$, $\io$) and show that we obtain well-known data structures.
$\maybe$-monsters are lazy lists, $\lstsym$-monsters are non-well-founded finitely branching trees, $\reader$-monsters are finite state machines, $\io$-monsters are interactive processes.
We prove equivalences between the traditional data types and their MonStr versions: the MonStr combinators instantiate to traditional operations.

Under some assumptions on the underlying functor/monad, we can prove that the MonStr type is also a Functor, an Applicative, or a Monad, giving us access to the special methods and notations of those type classes.
\end{abstract}

\include{s01_introduction}

\include{s02_monadic_streams}

\include{s03_coinduction}

\include{s04_examples}

\include{s05_operations}

\include{s06_type_classes}

\include{s07_related_work}

\include{s08_conclusions}

\bibliography{monster_biblio.bib}

\end{document}
