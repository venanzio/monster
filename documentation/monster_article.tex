\documentclass{article}
\usepackage{listings}
\usepackage{amsthm}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}

\title{Programming with Monsters}
\author{Venanzio Capretta and Christopher Purdy}

% lstlisting setup for Haskell
\lstset{
  frame=none,
  xleftmargin=2pt,
  belowcaptionskip=\bigskipamount,
  captionpos=b,
  escapeinside={*'}{'*},
  language=haskell,
  tabsize=2,
  emphstyle={\bf},
  commentstyle=\it,
  stringstyle=\mdseries\rmfamily,
  showspaces=false,
  keywordstyle=\bfseries\rmfamily,
  columns=flexible,
  basicstyle=\small\sffamily,
  showstringspaces=false,
  morecomment=[l]\%,
}

%format 

\begin{document}
\bibliographystyle{plain}

\maketitle

\begin{abstract}
A monadic stream is a potentially infinite sequence of values in which a monadic action is triggered at each step before the generation of the next element.
A monadic action consists of some functional {\em container} inside which the unfolding of the stream takes place.
Examples of monadic actions are: executing some input/output interactions, cloning the process into several parallel computations, executing transformations on an underlying state, terminating the sequence.

We develop a library of definitions and universal combinators to program with monadic streams and we prove several mathematical results about their behaviour.

We define the type of Monadic Streams (MonStr), dependent on two arguments: the underlying monad and the type of elements of the sequence.
We use the following terminology: a monadic stream with underlying monad $m$ is called an $m$-monster.
The definition itself doesn't depend on the fact that the underlying operator is a monad.
We define it generally: some of the operators can be defined without any assumptions, some others only need the operator to be a Functor or Applicative Functor.
A different set of important combinators and theoretical results follow from the assumption that the operator is a Co-Monad rather than a Monad.

We instantiate the abstract MonStr type with several common monads (Maybe, List, State, IO) and show that we obtain well-known data structures.
Maybe-monsters are lazy lists, List-monsters are non-well-founded finitely branching trees, IO-monsters are interactive processes.
We prove equivalences between the traditional data types and their MonStr versions: the MonStr combinators instantiate to traditional operations.

Under some assumptions on the underlying functor/monad, we can prove that the MonStr type is also a Functor, and Applicative, or a Monad, giving us access to the special methods and notations of those type classes.
\end{abstract}

\section{Introduction}

Intuitive explanation of Monadic Streams and motivation.

\section{Monadic Streams}

Formal definition of Monadic Streams.

\section{Examples}

Instantiations with Identity (Pure Streams), Maybe (Lazy Lists), List (Trees), IO (Processes), State (Stateful Streams).

Definition of the {\em standard} function on those data types in a general way.

\section{Instances of Functor, Applicative, Monad}

Show that monadic streams are an instance of these three classes, under some assumptions about the underlying monad.

So far we determined that we think that MonStr satisfies the monad laws if the underlying monad is commutative and idempotent \cite{idempotent_monads}. (Proof?)

What about Applicative?

Give conterexamples where it isn't a monad (using State).

Also examples when it is a monad even if the underlying monad is not commutative and idempotent: with List as underlying monad we obtain Trees, which are a monad. Can this be generalized.

\subsection{Functor instance in Haskell}

\begin{lstlisting}
	unwrapMS :: MonStr m a *'$\to$'* m (a, MonStr m a)
	unwrapMS (MCons m) = m

	transformMS :: Functor m *'$\Rightarrow$'* (a *'$\to$'* MonStr m a *'$\to$'* (b, MonStr m b)) *'$\to$'* 
	                                MonStr m a *'$\to$'* MonStr m b
	transformMS f s = MCons $ fmap (\(h,t) *'$\to$'* f h t) (unwrapMS s)

	instance Functor m *'$\Rightarrow$'* Functor (MonStr m) where
	   -- fmap :: (a *'$\to$'* b) *'$\to$'* MonStr m a *'$\to$'* MonStr m b
	   fmap f = transformMS (\a s *'$\to$'* (f a, fmap f s))
\end{lstlisting}

\subsubsection{Functor proof}

Proof of $fmap\ id == id$\\

\begin{lstlisting}
	fmap id = transformMS (\a s *'$\to$'* id a, fmap id s)
	-- definition of `transformMS`
	= \s *'$\to$'* MCons $ fmap (\(h,t) *'$\to$'* (\a s *'$\to$'* (id a, fmap id s)) h t) (unwrapMS s)
	-- application of `(\a s *'$\to$'* (id a, fmap id s))` to `h t`
	= \s *'$\to$'* MCons $ fmap (\(h,t) *'$\to$'* (id h, fmap id t)) (unwrapMS s)
	-- take as assumption that `fmap id t == id t` - coinductive hypothesis?
	= \s *'$\to$'* MCons $ fmap (\(h,t) *'$\to$'* (id h, id t)) (unwrapMS s)
	-- definition of `id`
	= \s *'$\to$'* MCons $ fmap (\(h,t) *'$\to$'* (h,t)) (unwrapMS s)
	-- definition of `id`
	= \s *'$\to$'* MCons $ fmap id (unwrapMS s)
	-- `unwrapMS` returns and element in a functor, so `fmap id == id` in this case 
	--  This doesn't seem formal enough?
	= \s *'$\to$'* MCons $ id (unwrapMS s)
	-- application of `id`
	= \s *'$\to$'* MCons $ (unwrapMS s)
	-- definition of `unwrapMS`
	= \s *'$\to$'* MCons $ (\(MCons m) *'$\to$'* m) s
	-- definition of `MCons` type constructor as a unary function
	= \s *'$\to$'* (\m *'$\to$'* MCons m) $ (\(MCons m) *'$\to$'* m) s
	-- "clearly" inverse functions?
	--  This step could be more formal by showing that they are inverses somehow?
	= \s *'$\to$'* id s 
	-- application of `id`
	= \s *'$\to$'* s
	-- definition of `id`
	= id
	*'\hfill$\qed$'*
	
\end{lstlisting}
Proof of $fmap\ (f \circ g) == (fmap\ f) \circ (fmap\ g) $

To simplify notation in the proof, we introduce the notation \verb+tr(f)+ for the expression \verb+\(h,t) -> (f h, fmap f t)+.

We're going to use the fact that the underlying operator \verb+m+ is a functor and so satisfied the functor laws, and also that the pairing operator \verb+(,)+ is functorial in both arguments.

By definition of \verb+fmap+ for monsters, we have that
\begin{lstlisting}
fmap f s = transformMS (\ a s -> (f a, fmap f s)) s
         = MCons $ fmap (\ (h,t) -> (\a s -> (f a, fmap f s) h t)) (unwrapMS s)
         = MCons $ fmap (\ (h,t) -> (f h, fmap f t)) (unwrapMS s)
         = MCons $ fmap tr(f) (unwrapMS s)
\end{lstlisting}


We also use the fact that the monster constructor \verb+MCon+ and the funcotion \verb+unwrapMS+ that removes it are inverse of each other.

\begin{lstlisting}
fmap (f . g) = transformMS (\a s *'$\to$'* (f . g) a, fmap (f . g) s)
-- definition of `transformMS`
= \s *'$\to$'* MCons $ fmap (\(h,t) *'$\to$'* (\a s *'$\to$'* ((f . g) a, fmap (f . g) s)) h t) (unwrapMS s)
-- application of `(\a s *'$\to$'* ((f . g) a, fmap (f . g) s))` to `h t`
= \s *'$\to$'* MCons $ fmap (\(h,t) *'$\to$'* ((f . g) h, fmap (f . g) t)) (unwrapMS s)`
-- take as assumption that `fmap (f . g) t == (fmap f . fmap g) t` - coinductive hypothesis?
= \s *'$\to$'* MCons $ fmap (\(h,t) *'$\to$'* ((f . g) h, (fmap f . fmap g) t)) (unwrapMS s)
-- By fuctoriality of pairing in both components
= \s *'$\to$'* MCons $ fmap (tr(f) . tr(g)) (unwrapMS s)
-- By functoriality of the underlying operator m
= \s *'$\to$'* MCons $ (fmap tr(f)) . (fmap tr(g)) (unwrapMS s)
-- MCons and unwrapMS are inverses
= \s *'$\to$'* MCons $ fmap tr(f)) $ unwrapMS $ MCons $ fmap tr(g) (unwrapMS s)
= \s *'$\to$'* MCons $ fmap tr(f)) $ unwrapMS $ fmap g s
= \s *'$\to$'* fmap f $ fmap g s
= fmap f . fmap g
\end{lstlisting}

\section{Applications}

Show a few application and motivate the usefulness of Monadic Streams.

\section{Conclusions}

Discussion of related literature.

Open problems.

Future Work.

\bibliography{biblio.bib}

\end{document}
