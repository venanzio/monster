\documentclass{article}

\usepackage{amssymb,amsmath,amsthm}
\usepackage{listings}
\usepackage{pstricks,pst-node}
\usepackage{hyperref}

\usepackage{tikz}
\usetikzlibrary{trees}

\usepackage[utf8]{inputenc}
\usepackage[english]{babel}

\title{Programming with Monsters}
\author{Christopher Purdy and Venanzio Capretta}

\usepackage{notations}

\newtheorem{definition}{Definition}
\newtheorem{theorem}[definition]{Theorem}
\newtheorem{proposition}[definition]{Proposition}
\newtheorem{lemma}[definition]{Lemma}
\newtheorem{example}[definition]{Example}
\newtheorem{conjecture}[definition]{Conjecture}

%format 

\begin{document}
\bibliographystyle{abbrv}

\maketitle

\begin{abstract}
A monadic stream is a potentially infinite sequence of values in which a {\em monadic action} is triggered at each step before the generation of the next element.
Monadic actions are a wide class of side effects, modes of execution, evaluation paradigms; they are realised as functional {\em containers} inside which the unfolding of the stream takes place.
Examples of monadic actions are: executing some input/output interactions, cloning the process into several parallel computations, executing transformations on an underlying state, terminating the sequence.

We develop a library of definitions and universal combinators to program with monadic streams and we prove several mathematical results about their behaviour.

We define the type of Monadic Streams ($\mathsf{MonStr}$), dependent on two arguments: the underlying monad (the kind of possible actions) and the type of elements of the sequence.
We use the following terminology: a monadic stream with underlying monad $M$ is called an $M$-\emph{monster}.
The definition itself doesn't depend on the fact that the underlying operator is a monad.
We define it generally: some of the operators can be defined without any assumptions, some others only need the operator to be a Functor or Applicative Functor.
A different set of important combinators and theoretical results follow from the assumption that the operator is a Comonad rather than a Monad.

We instantiate the abstract $\mathsf{MonStr}$ type with several common monads ($\maybe$, $\lstsym$, $\reader$, $\state$, $\io$) and show that we obtain well-known data structures.
$\maybe$-monsters are lazy lists, $\lstsym$-monsters are non-well-founded finitely branching trees, $\reader$-monsters are finite state machines, $\io$-monsters are interactive processes.
We prove equivalences between the traditional data types and their $\mathsf{MonStr}$ versions: the $\mathsf{MonStr}$ combinators instantiate to traditional operations.

Under some assumptions on the underlying functor/monad, we begin to prove that the $\mathsf{MonStr}$ type is also a Functor, an Applicative, a Monad, or a Comonad, giving us access to the special methods and notations of those type classes.
\end{abstract}

\input{s01_introduction}

\newpage

\input{s02_monadic_streams}

\input{s03_coinduction}

\newpage

\input{s04_examples}

\input{s05_operations}

\newpage

\input{s06_type_classes}

\input{s07_related_work}

\input{s08_conclusions}

\bibliography{monster_biblio.bib}

\end{document}
