\documentclass{article}

\usepackage{amssymb,amsmath,amsthm}
\usepackage{listings}
\usepackage{pstricks,pst-node}

\usepackage[utf8]{inputenc}
\usepackage[english]{babel}

\title{Programming with Monsters}
\author{Venanzio Capretta and Christopher Purdy}


\usepackage{notations}

\newtheorem{definition}{Definition}
\newtheorem{theorem}{Theorem}
\newtheorem{proposition}{Proposition}
\newtheorem{example}{Example}

%format 

\begin{document}
\bibliographystyle{plain}

\maketitle

\begin{abstract}
A monadic stream is a potentially infinite sequence of values in which a monadic action is triggered at each step before the generation of the next element.
A monadic action consists of some functional {\em container} inside which the unfolding of the stream takes place.
Examples of monadic actions are: executing some input/output interactions, cloning the process into several parallel computations, executing transformations on an underlying state, terminating the sequence.

We develop a library of definitions and universal combinators to program with monadic streams and we prove several mathematical results about their behaviour.

We define the type of Monadic Streams (MonStr), dependent on two arguments: the underlying monad and the type of elements of the sequence.
We use the following terminology: a monadic stream with underlying monad $m$ is called an $m$-monster.
The definition itself doesn't depend on the fact that the underlying operator is a monad.
We define it generally: some of the operators can be defined without any assumptions, some others only need the operator to be a Functor or Applicative Functor.
A different set of important combinators and theoretical results follow from the assumption that the operator is a Co-Monad rather than a Monad.

We instantiate the abstract MonStr type with several common monads (Maybe, List, State, IO) and show that we obtain well-known data structures.
Maybe-monsters are lazy lists, List-monsters are non-well-founded finitely branching trees, IO-monsters are interactive processes.
We prove equivalences between the traditional data types and their MonStr versions: the MonStr combinators instantiate to traditional operations.

Under some assumptions on the underlying functor/monad, we can prove that the MonStr type is also a Functor, and Applicative, or a Monad, giving us access to the special methods and notations of those type classes.
\end{abstract}

\section{Introduction}

Intuitive explanation of Monadic Streams and motivation.

\section{Monadic Streams}

A monadic stream is a sequence of values in which every stage is obtained by triggering a monadic action.
If $\sigma$ is such a stream, it will consist of an action for a certain monad $M$ that, when executed, will return a head (first element) and a tail (continuation of the stream).
This process can be continued in a non-well-founded way: streams constitute a coinductive type.

Formally the type of streams over a monad $M$ (let's call them $M$-monsters) is defined as:
$$
\begin{array}[t]{l}
\codata\;
\stream{M,A}:\set\\
\quad \mcons_M: M\,(A\times \stream{M,A})\rightarrow\stream{M,A}.
\end{array}
$$
Categorically, we can see this type as the final coalgebra of the functor $F\,X-= = M\,(A\times X)$. (This final coalgebra does not necessarily exists for every $M$, we will discuss this issue below.)


Instantiating $M$ with some of the most well-known monads leads to versions of known data types or to interesting new constructs.

If we instantiate $M$ with the identity monad, we obtain the type of pure streams.
Its usual definition is the following:
$$
\begin{array}[t]{l}
\codata\;
\stream{A}:\set\\
\quad (\scons): \nat\rightarrow \stream{\nat} \rightarrow\stream{\nat}.
\end{array}
$$
(The type of the constructor has been curried, as is common.)
An element of $\stream{A}$ is an infinite sequence of elements of $A$: $a_0 \scons a_1\scons a_2\scons \cdots$.

If we instantiate $M$ with the $\maybe$ monad we obtain the type $\stream{\maybe,A}$, equivalent to the type of lazy lists $\lst{A}$.
The $\maybe$ monad is a functor that adds an extra element to the argument type: $\maybe\,X \cong X+1$, so the single constructor $\mcons_\maybe: \maybe\,(A\times \stream{\maybe,A})\rightarrow\stream{\maybe,A}$ is equivalent to two constructors (for $\nothing$ and $\just$):
$$
\begin{array}[t]{l}
\codata\;
\lst{A}:\set\\
\quad (\scons): A\times \lst{A}\rightarrow\lst{A}\\
\quad \nil: \lst{A}.
\end{array}
$$
This means that an element of $\lst{A}$ is either an empty sequence $\nil$ or a non-empty sequence $a\scons \sigma$ where $a:A$ and $\sigma$ is recursively an element of $\lst{A}$.
Since this is a coinductive type, the constructor $(\scons)$ can be applied an infinite number of times.
Therefore $\lst{A}$ is the type of finite and infinite sequences.


\begin{vcomment}
Add example with $M = \lstsym $ (maybe introduce different notations for lazy and strict lists) and give some simple example of functions on monsters.
\end{vcomment}







It is important to make two observations about $M$.

First, $M$ does not need to be a monad for the definition to make sense.
In fact we will obtain several interesting results when $M$ satisfies weaker conditions, for example being just a functor.
So we will take $M$ to be any type operator (but see second observation) and we will explicitly state what properties we assume about it.
The most important instances are monads and it is convenient to use the facilities of monadic notation in programming and monad theory in reasoning.

The second observation is that it is not guaranteed in general that the $\codata$ type is well-defined.
Haskell will accept the definition when $M$ is any functor, but mathematically the type is well defined only when the functor $F\,X = M\,(A\times X)$ has a final coalgebra.

\begin{definition}\label{def:fincoal}
For any functor $F$, a {\em coalgebra} for $F$ is pair $\langle A,\alpha\rangle$ consisting of a type $A$ and a function $\alpha:A\rightarrow FA$.

We say that $\langle A,\alpha\rangle$ is a {\em final $F$-coalgebra} if, 
for every coalgebra $\langle X,\xi:X\rightarrow FX\rangle$, 
there is a unique coalgebra morphism between the the two coalgebras:
$f:\langle X,\xi\rangle \to \langle A,\alpha\rangle$.
Such a morphism is a function between the types that commutes with the coalgebra functions:
$$
\setlength\arraycolsep{30pt}
\begin{array}{cc} \ \\
\Rnode{a}{A} & \Rnode{fa}{FA} \\[30pt]
\Rnode{x}{X} & \Rnode{fx}{FX} \\ \ 
\end{array}
\psset{nodesep=5pt,arrows=->}
\ncline{a}{fa} \taput{\alpha}
\ncline{x}{fx} \tbput{\xi}
\ncline[linestyle=dotted]{x}{a}  \tlput{f}
\ncline{fx}{fa} \trput{Ff}
\qquad \alpha \circ f = Ff \circ \xi.
$$
\end{definition}

This definition means that we can define function into a coinductive type by giving a coalgebra.
For example, consider the data type of pure streams of natural numbers:
The type $\stream{A}$ is the final coalgebra of the functor $F(X) = A\times X$.

We can define a function into $\stream{A}$ by defining a coalgebra on the domain type.
For example, if we want to define a function that maps any natural number $n$ to the stream of numbers starting from $n$, $n\scons (n+1) \scons (n+2) \scons (n+3) \scons \cdots$, we can do it by the following coalgebra on $\nat$:
$$
\begin{array}{l}
\xi : \nat \rightarrow \nat\times \nat\\
\xi\,n = \langle n,n+1\rangle
\end{array}
$$
(Note that the target type of the coalgebra is $F(\nat) = \nat\times\nat$: The first $\nat$ is the parameter of the functor, while the second $\nat$ is the carrier of the coalgebra.)

In practical programming, we often let the coalgebra $\xi$ be implicit by directly defining the function $f$ recursively.
For example, the function above would be defined as:
$$
\begin{array}{l}
f: \nat \rightarrow \stream{\nat}\\
f\,n = n \scons f\,(n+1)
\end{array}
$$
Here the presence of the parameter $n$ and the argument of the recursive call $n+1$ implicitely give the coalgebra $n \mapsto \langle n, n+1\rangle$.

\begin{vcomment}
Talk about definition by guarded recursion.
Show specific examples of definition by guarded recursion for monsters.
\end{vcomment}




The definition of $\stream{M,A}$ is not meaningful for all $M$s, because the final coalgebra may not exist or not be unique.
A useful result is that a functor has a final coalgebra if it is a container \cite{AAG:2005}, and $F$ is a container if $M$ is \cite{capretta/fowler:2017}.
This is the case for all the instances that we consider (but there are well known counterexamples, like the powerset functor and the continuation functor).

Therefore we will silently assume that $M$ is a container and that the final coalgebra exists.
Cofinality means that we can define functions into the coalgebra by {\em corecursion} and we can prove properties of its elements by {\em coinduction}.

\section{Examples}

Instantiations with Identity (Pure Streams), Maybe (Lazy Lists), List (Trees), IO (Processes), State (Stateful Streams).

Definition of the {\em standard} function on those data types in a general way.

\section{Instances of Functor, Applicative, Monad}

Show that monadic streams are an instance of these three classes, under some assumptions about the underlying monad.

So far we determined that we think that MonStr satisfies the monad laws if the underlying monad is commutative and idempotent \cite{idempotent_monads}. (Proof?)

What about Applicative?

Give conterexamples where it isn't a monad (using State).

Also examples when it is a monad even if the underlying monad is not commutative and idempotent: with List as underlying monad we obtain Trees, which are a monad. Can this be generalized.

\subsection{Functor instance in Haskell}

\begin{haskell}
unwrapMS :: MonStr m a -> m (a, MonStr m a)
unwrapMS (MCons m) = m

transformMS :: Functor m => (a -> MonStr m a -> (b, MonStr m b)) ->
                                  MonStr m a -> MonStr m b
transformMS f s = MCons $ fmap (\(h,t) -> f h t) (unwrapMS s)

instance Functor m => Functor (MonStr m) where
   -- fmap :: (a -> b) -> MonStr m a -> MonStr m b
   fmap f = transformMS (\a s -> (f a, fmap f s))
\end{haskell}

\subsubsection{Functor proof}

Proof that \hcode{fmap id == id}

\begin{haskell}
fmap id = transformMS (\a s -> id a, fmap id s)
-- definition of `transformMS`
= \s -> MCons $ fmap (\(h,t) -> (\a s -> (id a, fmap id s)) h t) (unwrapMS s)
-- application of `(\a s -> (id a, fmap id s))` to `h t`
= \s -> MCons $ fmap (\(h,t) -> (id h, fmap id t)) (unwrapMS s)
-- take as assumption that `fmap id t == id t` - coinductive hypothesis?
= \s -> MCons $ fmap (\(h,t) -> (id h, id t)) (unwrapMS s)
-- definition of `id`
= \s -> MCons $ fmap (\(h,t) -> (h,t)) (unwrapMS s)
-- definition of `id`
= \s -> MCons $ fmap id (unwrapMS s)
-- `unwrapMS` returns an element in a functor, so `fmap id == id` in this case
= \s -> MCons $ id (unwrapMS s)
-- application of `id`
= \s -> MCons $ (unwrapMS s)
-- MCons and unwrapMS are inverses
= \s -> id s 
= id
\end{haskell}

Proof that \verb+fmap (f . g) == (fmap f) . (fmap g)+

To simplify notation in the proof, we introduce the notation \verb+tr(f)+ for the expression \verb+\(h,t) -> (f h, fmap f t)+.

We're going to use the fact that the underlying operator \verb+m+ is a functor and so satisfies the functor laws, and also that the pairing operator \verb+(,)+ is functorial in both arguments.

By definition of \verb+fmap+ for monsters, we have that
\begin{haskell}
fmap f s = transformMS (\ a s -> (f a, fmap f s)) s
         = MCons $ fmap (\ (h,t) -> (\a s -> (f a, fmap f s) h t)) (unwrapMS s)
         = MCons $ fmap (\ (h,t) -> (f h, fmap f t)) (unwrapMS s)
         = MCons $ fmap tr(f) (unwrapMS s)
\end{haskell}

We also use the fact that the monster constructor \verb+MCons+ and the function \verb+unwrapMS+ that removes it are inverse of each other.

\begin{haskell}
fmap (f . g) = transformMS (\a s -> (f . g) a, fmap (f . g) s)
-- definition of `transformMS`
= \s -> MCons $ fmap (\(h,t) -> (\a s -> ((f . g) a, fmap (f . g) s)) h t) (unwrapMS s)
-- application of `(\a s -> ((f . g) a, fmap (f . g) s))` to `h t`
= \s -> MCons $ fmap (\(h,t) -> ((f . g) h, fmap (f . g) t)) (unwrapMS s)`
-- take as assumption that `fmap (f . g) t == (fmap f . fmap g) t` - coinductive hypothesis?
= \s -> MCons $ fmap (\(h,t) -> ((f . g) h, (fmap f . fmap g) t)) (unwrapMS s)
-- By fuctoriality of pairing in both components
= \s -> MCons $ fmap (tr(f) . tr(g)) (unwrapMS s)
-- By functoriality of the underlying operator m
= \s -> MCons $ (fmap tr(f)) . (fmap tr(g)) (unwrapMS s)
-- MCons and unwrapMS are inverses
= \s -> MCons $ fmap tr(f)) $ unwrapMS $ MCons $ fmap tr(g) (unwrapMS s)
= \s -> MCons $ fmap tr(f)) $ unwrapMS $ fmap g s
= \s -> fmap f $ fmap g s
= fmap f . fmap g
\end{haskell}

\subsection{Comonad instance in Haskell}

\begin{haskell}
instance Comonad w => Comonad (MonStr w) where
  --extract :: MonStr w a -> a
  extract = extract . headMS
  
  --duplicate :: MonStr w a -> MonStr w (MonStr w a)
  duplicate s = MCons $ fmap (\(h,t) -> (s, duplicate t)) (unwrapMS s)
\end{haskell}

\verb+headMS+ returns the first element of the first pair in the monster, wrapped in the underlying functor. Since this functor is required to be a comonad, extract can be used to return the wrapped values inside.

We introduce \verb+mm(s)+ for the "monster matrix" formed by a monadic stream \verb+s+ - this is defined as a monster where the first element is \verb+s+, the second is the tail of \verb+s+, the third is the tail of the tail of \verb+s+, and so on.

The \verb+duplicate+ instance for monadic streams forms this "monster matrix": \verb+duplicate s = mm(s)+

\subsubsection{Comonad proof}

Proof that \verb+extract . duplicate == id+

\begin{haskell}
extract . duplicate = \s -> (extract . headMS) . duplicate $ s
= \s -> (extract . headMS) (duplicate s)
-- duplicate forms a monster matrix
= \s -> (extract . headMS) mm(s)
-- the first element of the monster matrix is the original stream, as per the definition above.
-- taking the head returns the original stream guarded by the operator m, and extract then retrieves 
-- s due to m being comonadic
= \s -> s
= id
\end{haskell}

Proof that \verb+fmap extract . duplicate == id+

\begin{haskell}
fmap extract . duplicate = \s -> fmap (extract . headMS) mm(s)
-- by functoriality of underlying operator m
= \s -> (fmap extract) . (fmap headMS) $ mm(s)
-- fmapping headMS replaces the monster at each step in the monster matrix with its
-- head, inside the operator. extract then removes these comonadic operators, resulting 
-- in the same monster that we started with
= \s -> s
= id
\end{haskell}

Proof that \verb+duplicate . duplicate == fmap duplicate . duplicate+


\section{Monad proof}

\begin{definition}\label{def:monad}
For any endofunctor $T$ on a category $C$, a {\em monad} is a triple $(T, \mu, \eta)$, of $T$ and two natural transformations $\mu : TT \Rightarrow T$ and $\eta : 1_C \Rightarrow T$ ($1_C$ being the identity functor on $C$) such that these diagrams commute:
$$
\setlength\arraycolsep{30pt}
\begin{array}{cc} \ \\
\Rnode{t1}{TA} & \Rnode{tt}{TTA} \\[30pt]
 & \Rnode{t2}{TA} \\ \ 
\end{array}
\psset{nodesep=5pt,arrows=->}
\ncline{t1}{tt} \taput{\eta_{TA}}
\ncline{tt}{t2} \trput{\mu}
\ncline{t1}{t2} \tbput{id_{TA}}
\qquad 
\setlength\arraycolsep{30pt}
\begin{array}{cc} \ \\
\Rnode{t1}{TA} & \Rnode{tt}{TTA} \\[30pt]
 & \Rnode{t2}{TA} \\ \ 
\end{array}
\psset{nodesep=5pt,arrows=->}
\ncline{t1}{tt} \taput{T\eta_{A}}
\ncline{tt}{t2} \trput{\mu}
\ncline{t1}{t2} \tbput{id_{TA}}
$$
$$
\setlength\arraycolsep{30pt}
\begin{array}{cc} \ \\
\Rnode{ttt}{TTTA} & \Rnode{tt1}{TTA} \\[30pt]
\Rnode{tt2}{TTA} & \Rnode{t}{TA} \\ \ 
\end{array}
\psset{nodesep=5pt,arrows=->}
\ncline{ttt}{tt1} \taput{\mu T}
\ncline{ttt}{tt2} \tlput{T\mu}
\ncline{tt2}{t} \tbput{\mu}
\ncline{tt1}{t} \trput{\mu}
$$
\end{definition}

For the functor $\stream{M}$ to be a monad, the monad laws (these commuting diagrams) need to be satisfied. However, assuming a monad $(\stream{M}, \mu, \eta)$, the left identity law (top-left diagram) does not hold in general, given an arbitrary underlying monad $M$. This is due to a correct $\mu$ not being constructible.\\

Here, subscripts of $\eta$ (and $\mu$) indicate their monad, and not components of the natural transformation - these are instead indicated using function application: $\eta_M(x)$ where $x : A$ implies that we are using the component of $\eta_M$ at $A$. \\

First, note that $\eta_{\stream{M}}$ has to be defined as:

$$\eta_{\stream{M}}(x) = mcons_M(\eta_M ((x, \eta_{\stream{M}}(x)))$$ 

There is one choice of $A$ for the first element of the pair, and only one way of lifting pairs into the inner monad $M$, which is by using $\eta_M$. The second element of the pair has to be a $\stream{M,A}$, and the only way to produce this here is by a recursive call.\\

We introduce the notation $\mathop{|}_M^i$ to denote a monadic stream constructor guarded by a monadic action $m_i : A \to MA$. Since each monadic action in $M$ may be different, $i$ is just a label to indicate when they are the same. That is, for any $i$, and a fixed $a : A$:
\begin{align*}
&s_0 : \stream{M,A} = \mathop{|}_M^i a, s_0\\
&s_1 : \stream{M,A} = \mathop{|}_M^i a, s_1\\
&s_0 = s_1
\end{align*}
If $i = \eta$, this monadic action is the monad $M$'s unit, the natural transformation $\eta_M$. For any other label $i$, the monadic action is arbitrary. If there is no label, whether the monadic actions are equal is not being considered.\\

\begin{proof}
If $(\stream{M}, \mu, \eta)$ is a monad, then it needs to obey the left identity law, which in this case is
$$
\mu_{\stream{M}}(\eta_{\stream{M}}(s)) = s
\qquad s : \stream{M,A}
$$
For an arbitrary steam $s$, defined as:
$$
s = \mathop{|}_M^0 a_0, \mathop{|}_M^1 a_1, \mathop{|}_M^2  a_2, \dots
$$
First we construct the $M$-monster of $M$-monsters (termed an $M$-matrix) as per this requirement:
\begin{align*}
&\eta_{\stream{M}}(s) : \stream{M,\stream{M,A}} = \mathop{|}_M^\eta s, \mathop{|}_M^\eta s, \mathop{|}_M^\eta s, \dots
\end{align*}
To take the diagonal, you have to take the first element of the first stream, the second of the second stream, and so on. The law says that $\eta_{\stream{M}}(s)$ needs to be somehow manipulated to form $s$. \\

We reason that $\mu_{\stream{M}}$ cannot be constructed by noting that there is no function out of a monad in general (no function $f : MA \to A$ for an arbitrary functor M over which a monad is defined), and then traversing the $M$-matrix to see which monadic actions \emph{necessarily} have to guard each element in the $M$-monster resulting from an application of $\mu_{\stream{M}}$ to $\eta_{\stream{M}}(s)$.\\

Observe that the first element of the first stream $a_0$ in $\eta_{\stream{M,A}}(s)$ is guarded by two monadic actions, one of them $\eta$, the other an arbitrary action, which we'll call $m_0 : A \to MA$. By the left identity on the monad $M$, $\eta(m_0(a_0)) = m_0(a_0)$, which indicates that in the absolute best case, the first element of the $M$-monster is guarded by $m_0$.
$$
\eta_{\stream{M}}(s) : \stream{M,\stream{M,A}} = \mathop{|}_M^\eta (\mathop{|}_M^0 \stackrel{\downarrow}{a_0}, \mathop{|}_M^1 a_1, \dots), \mathop{|}_M^\eta s, \dots
$$
Now that we know the first element of the resulting stream $a_0$ will be, in the best case, guarded by $m_0$, we look at what actions guard the second element $a_1$. WLOG, there are two ways to extract $a_1$, either by taking the second element of the second $M$-monster, or by taking the second element of the first $M$-monster. This gives two cases to consider.\\

\paragraph{Case 1:}

In the first case: if we take the second element of the second $M$-monster, then we have to consider what actions guard the element $a_1$ - these in order are $\eta, \eta, m_0, m_1$, obtained by traversing along $\eta_{\stream{M}}(s)$ to the second $s$, and then along $s$ to $a_1$. By using the left identity again, this could reduce in the best case to $m_0(m_1(a_1))$.

$$
\eta_{\stream{M}}(s) : \stream{M,\stream{M,A}} = \mathop{|}_M^\eta s, \mathop{|}_M^\eta (\mathop{|}_M^0 a_0, \mathop{|}_M^1 \stackrel{\downarrow}{a_1}, \dots), \dots
$$

Now realise that in $s$, the element $a_0$ comes before $a_1$. This means that any monadic actions guarding $a_0$, have to also guard $a_1$. Crucially, the $m_0$ actions that guard them \emph{are not the same}, one comes from the first $s$, and the other from the second $s$. This means $a_1$ has to be guarded by \emph{two copies} of $m_0$ - one from the $s$ in the first index of $\eta_{\stream{M}}(s)$ (which is required to guard $a_0$), and one from the second. 

As you cannot get rid of this extra monadic action in general, $s$ is not constructible from $\eta_{\stream{M}}(s)$ in this way. The problem with a duplicated monadic action can be demonstrated with the State monad - if you have an action that adds $3$ to an underlying state, duplicating this would produce an overall action of adding $6$.\\


\paragraph{Case 2:} 

The second case to consider was to take the second element from the first stream. To show this doesn't work generally either, we have to instead consider the right monad identity law. This states that:

$$
\mu_{\stream{M}}(\stream{M}\eta_{\stream{M}}(s)) = s
\qquad s : \stream{M,A}
$$

Where $\stream{M}\eta_{\stream{M}}$ lifts $\eta_{\stream{M}}$ to a function on monadic streams, which effectively applies it to each of the elements (this is our \verb+fmap+ definition from earlier). We redefine the $M$-matrix accordingly:
\begin{align*}
&a_i : A\\
&\eta_{\stream{M}}(a_i) : \stream{M,A} = \mathop{|}_M^\eta a_i, \mathop{|}_M^\eta a_i, \mathop{|}_M^\eta  a_i, \dots\\
&\stream{M}\eta_{\stream{M}}(s) : \stream{M,\stream{M,A}} = \mathop{|}_M^0 \eta_{\stream{M}}(a_0), \mathop{|}_M^1 \eta_{\stream{M}}(a_1), \mathop{|}_M^2 \eta_{\stream{M}}(a_2), \dots
\end{align*}

Using similar logic to before, you can show that $a_0$ is guarded by at least $m_0$. However, if you pick the second element from the second stream, you get another $a_0$. The $\mu_{\stream{M,A}}$ operation has to cross over to the next 'sub-monster' $\eta_{\stream{M}}(a_1)$ to get the value $a_1$. This loops us back to the first case, where we show that doing this causes a duplication of monadic actions, considering the left identity. 

\end{proof}



\section{Applications}

\begin{ccomment}
	Show a few applications and motivate the usefulness of Monadic Streams.
\end{ccomment}

One application from monadic streams is they can be seen as a generalised form of Yampa's \cite{yampa_arcade} signal functions. For example, one can implement the integral signal function using the Reader functor. First you define the type of monadic stream - we use the same names as for the same constructs in Yampa, to make the correspondence clear:

\begin{haskell}
type DTime = Double

type SignalFunc a b = MonStr ((->) (DTime, a)) b
\end{haskell}

\begin{haskell}
integral :: SignalFunc Double Double
integral = MCons integralAuxF
                 
integralAuxF :: (DTime, Double) -> (Double, SignalFunc DTime Double)
integralAuxF (_, a) = (0 , integralAux 0 a)
   where integralAux igrl a_prev = MCons (\(dt, a') -> 
   		(igrl' dt, integralAux (igrl' dt) a'))
      where igrl' dt' = igrl + (dt' * a_prev)
\end{haskell}


\section{Conclusions}

Discussion of related literature.

Open problems.

Future Work.

\bibliography{biblio.bib}

\end{document}
