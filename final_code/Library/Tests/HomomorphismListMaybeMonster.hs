{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE TemplateHaskell #-}

module Tests.HomomorphismListMaybeMonster where

import Test.QuickCheck
import Test.QuickCheck.Gen.Unsafe
import Test.QuickCheck.All

import MonadicStreams
import Examples.LazyLists
import Data.Maybe

import Control.Monad hiding (filterM)
import Data.Foldable

import Prelude hiding ((!!), (++), iterate, head, tail, cycle)
import Data.List hiding (head, tail, iterate, (++), repeat, cycle, (!!))
import qualified Data.List as DL ((!!), (++), head, tail, intersperse, iterate)

{- 
 | This instance creates very basic monadic streams, where each action is the return "do-nothing" 
 action in that monad
  
 For example a generated List-monster would look like: [(x_0,[(x_1,[(x_2,[(x_3,...,
 and a generated Maybe-monster would look like: Just (x_0, Just (x_1, Just (x_2, Just (x_3, ...
 where x_n is some random element generated by the arbitrary instance for the type of x

 This is fine for Id and Maybe, but not so much for [] and State s for example.
-}
instance (Monad m, Arbitrary a) => Arbitrary (MonStr m a) where
   arbitrary = fmap MCons $ promote (return (liftM2 (,) arbitrary arbitrary))
  
genMaybeMonStr :: Gen (MonStr Maybe Int)
genMaybeMonStr = do x <- chooseInt (1, 1000)
                    fmap (insertM x Nothing) arbitrary

instance Eq a => Eq (MonStr Maybe a) where
   (MCons (Just (h,t))) == (MCons (Just (h',t'))) = h == h' && t == t'
   (MCons Nothing)      == (MCons Nothing)        = True
   (MCons _)            == (MCons Nothing)        = False
   (MCons Nothing)      == (MCons _)              = False

-- | Tests for isomorphism between list and maybe monster, with llist and toList 
-- being the isomorphisms between the types, whose composition has to equal id

prop_monStr :: Property
prop_monStr = forAll genMaybeMonStr $ (\mas -> mas === llist (toList mas))

prop_list :: Property
prop_list = forAll genList $ (\ls -> ls === toList (llist ls))


-- | Helper functions to generate lists and monsters for the tests below 

(>*<) :: Gen a -> Gen b -> Gen (a, b)
a >*< b = liftM2 (,) a b

gen2Lists :: Gen ([Int],[Int])
gen2Lists = listOf1 (chooseInt (-1000,1000)) >*< listOf1 (chooseInt (-1000,1000))

genList :: Gen ([Int])
genList = listOf1 (chooseInt (-1000,1000))

-- | Generates a random list and Maybe-monster with the same values
                   
genListMonStr :: Gen ([Int], MonStr Maybe Int)
genListMonStr = do l <- (listOf1 (arbitrary :: Gen Int))
                   return (l, llist l)
                   
genPairListMonStr :: Gen ([(Int, Int)], MonStr Maybe (Int, Int))
genPairListMonStr = do l <- (listOf1 (arbitrary :: Gen (Int, Int)))
                       return (l, llist l)

{- 
 | Tests to compare functions in Operations to those in Data.List
  
 Any test that fails has a version with some extra constraints 
 that passes - this usually indicates that the more general monadic
 stream operation of that name isn't suited for finite data structures
-}

-- PASSES
prop_inits :: Property
prop_inits = forAll genListMonStr $
                \(l, ms) -> toList (initsA ms) === inits l

{-
-- !!! FAILS !!! - tailM (MCons Nothing) = Nothing, so tailsM recurses forever     
prop_tails :: Property
prop_tails = forAll genListMonStr $
                \(l, ms) -> fmap toList (tailsM ms) === tails l
-}
               
-- PASSES
prop_tails :: Property
prop_tails = forAll genListMonStr $
                \(l, ms) -> fmap toList (tailsMF ms) === tails l

{-
-- !!! FAILS !!! - takeM n (MCons Just (1, MCons Nothing)) where n > 0 gives
-- Nothing, but take n [1] = [1]
prop_take :: Property
prop_take = forAll (genListMonStr >*< chooseInt (0,1000)) $
               \((l, ms), n) -> takeM n ms === Just (take n l)
               
-- !!! FAILS !!! - same reason as prop_take
prop_take' :: Property
prop_take' = forAll (genListMonStr >*< chooseInt (0,1000)) $
                \((l, ms), n) -> takeM' n ms === Just (take n l)

-- !!! FAILS !!! - takeM'' n ms - always generates a list of n values, 
-- with the last ones being empty (Nothing/null) values if n is larger than the 
-- length of ms
prop_take'' :: Property
prop_take'' = forAll (genListMonStr >*< chooseInt (0,1000)) $
                 \((l, ms), n) -> takeM'' n ms === fmap Just (take n l)
-}
               
-- PASSES
prop_take :: Property
prop_take = forAll (genListMonStr >*< chooseInt (0,1000)) $
               \((l, ms), n) -> takeMF' n ms === Just (take n l)

-- PASSES
prop_drop :: Property
prop_drop = forAll (genListMonStr >*< chooseInt (0,1000)) $
               \((l, ms), n) -> drop n l === toList (dropM n ms)
-- PASSES
prop_scan :: Property
prop_scan = forAll ((genListMonStr >*< chooseInt (-1000,1000)) >*< (arbitrary :: Gen(Fun (Int,Int) Int)) ) $ 
               \(((l,ms),n),(Fn2 f)) -> toList (scanA f n ms) === scanl f n l

-- PASSES
prop_scan' :: Property
prop_scan' = forAll (genListMonStr >*< (arbitrary :: Gen(Fun (Int,Int) Int)) ) $ 
                \((l,ms),(Fn2 f)) -> toList (scanM f ms) === scanl1 f l
 
-- PASSES              
prop_append :: Property
prop_append = forAll (genListMonStr >*< genListMonStr) $
                 \((l,ms),(l',ms')) -> toList (ms ++ ms') === l DL.++ l'

{-
-- !!! FAILS !!! - fails when taking 1 item from a monster with 1 element 
-- which satisifes the predicate, spanM tries to put that elment inside 
-- the Nothing tail when returning it
prop_span :: Property
prop_span = forAll (genListMonStr >*< (arbitrary :: Gen(Fun Int Bool)) ) $ 
               \((l,ms),(Fn p)) -> fmap (\(a,b) -> (a,toList b)) (spanM p ms) === Just (span p l)
-}

-- PASSES
prop_span :: Property
prop_span = forAll (genListMonStr >*< (arbitrary :: Gen(Fun Int Bool)) ) $ 
               \((l,ms),(Fn p)) -> fmap (\(a,b) -> (a,toList b)) (spanMF p ms) === Just (span p l)
        
-- PASSES
prop_break :: Property
prop_break = forAll (genListMonStr >*< (arbitrary :: Gen(Fun Int Bool)) ) $ 
                \((l,ms),(Fn p)) -> fmap (\(a,b) -> (a,toList b)) (breakMF p ms) === Just (break p l)

-- PASSES
prop_init :: Property
prop_init = forAll genListMonStr $ 
               \(l,ms) -> initMF ms === fmap Just (init l)

-- PASSES
prop_init' :: Property
prop_init' = forAll genListMonStr $ 
                \(l,ms) -> initMF' ms === Just (init l)

-- PASSES
prop_init'' :: Property
prop_init'' = forAll genListMonStr $ 
                 \(l,ms) -> toList (initMF'' ms) === init l

-- PASSES
prop_length :: Property
prop_length = forAll genListMonStr $ 
                 \(l,ms) -> length ms === length l
                 
-- PASSES
prop_last :: Property
prop_last = forAll genListMonStr $ 
               \(l,ms) -> lastMF ms === Just (last l)

-- PASSES
prop_zip :: Property
prop_zip = forAll (genListMonStr >*< genListMonStr) $ 
              \((l,ms),(l',ms')) -> toList (zipA ms ms') === zip l l'
        
-- PASSES
prop_unzip :: Property
prop_unzip = forAll genPairListMonStr $ 
                \(l,ms) -> (\(a,b) -> (toList a, toList b)) (unzipA ms) === unzip l

-- PASSES
prop_zipWith :: Property
prop_zipWith = forAll ((genListMonStr >*< genListMonStr) >*< (arbitrary :: Gen(Fun (Int,Int) Int))) $ 
                  \(((l,ms),(l',ms')),(Fn2 f)) -> toList (zipWithA f ms ms') === zipWith f l l'
            
-- PASSES
prop_filter :: Property
prop_filter = forAll (genListMonStr >*< (arbitrary :: Gen(Fun Int Bool)) ) $ 
                 \((l,ms),(Fn p)) -> toList (filterM p ms) === filter p l

-- PASSES
prop_map :: Property
prop_map = forAll (genListMonStr >*< (arbitrary :: Gen(Fun Int Int)) ) $ 
              \((l,ms),(Fn f)) -> toList (fmap f ms) === map f l

-- PASSES
prop_head :: Property
prop_head = forAll genListMonStr $
               \(l, ms) -> Just (DL.head l) === head ms

-- PASSES
prop_tail :: Property
prop_tail = forAll genListMonStr $
               \(l, ms) -> Just (DL.tail l) === fmap toList (tail ms)

-- PASSES
prop_tail' :: Property
prop_tail' = forAll genListMonStr $
                \(l, ms) -> DL.tail l === toList (tailMF ms)

-- PASSES
prop_index :: Property
prop_index = forAll (genListMonStr >*< chooseInt (0,1000)) $
                \((l, ms), n) -> let i = min n (length l - 1) in 
                                    Just (l DL.!! i) === ms !! i

{-
-- !!! FAILS !!! - makes use of spanM so groupM is broken for the same reason
prop_group :: Property
prop_group = forAll genListMonStr $
                \(l, ms) -> group l === toList (groupM ms)
-}
                                   
-- PASSES
prop_group :: Property
prop_group = forAll genListMonStr $
                \(l, ms) -> group l === toList (groupMF ms)
                 
-- PASSES
prop_partition :: Property
prop_partition = forAll ( genListMonStr >*< (arbitrary :: Gen(Fun Int Bool)) ) $ 
                    \((l, ms),(Fn p)) -> Just (partition p l) === fmap (\(a,b) -> (toList a, toList b)) (partitionMF p ms)

{-
-- !!! FAILS !!! - when the index is larger than the list, splitAtM returns 
-- lots of 'Nothing's padding the end of the first list in the pair
prop_splitAt :: Property
prop_splitAt = forAll (genListMonStr >*< chooseInt (0,1000)) $
                  \((l, ms), n) -> ((\(a,b) -> (fmap Just a, llist b)) (splitAt n l)) === splitAtM n ms
-}
                               
-- PASSES
prop_splitAt :: Property
prop_splitAt = forAll (genListMonStr >*< chooseInt (0,1000)) $
                  \((l, ms), n) -> ((\(a,b) -> (fmap Just a, llist b)) (splitAt n l)) === splitAtMF n ms

{-
-- !!! FAILS !!! - makes use of spanM which is broken for non-foldable monsters
prop_takeWhile :: Property
prop_takeWhile = forAll ( genListMonStr >*< (arbitrary :: Gen(Fun Int Bool)) ) $ 
                    \((l, ms),(Fn p)) -> Just (takeWhile p l) === takeWhileM p ms
-}

-- PASSES
prop_takeWhile :: Property
prop_takeWhile = forAll ( genListMonStr >*< (arbitrary :: Gen(Fun Int Bool)) ) $ 
                    \((l, ms),(Fn p)) -> Just (takeWhile p l) === takeWhileMF p ms

-- PASSES
prop_dropWhile :: Property
prop_dropWhile = forAll ( genListMonStr >*< (arbitrary :: Gen(Fun Int Bool)) ) $ 
                    \((l, ms),(Fn p)) -> dropWhile p l === toList (dropWhileMF p ms)

-- PASSES
prop_intersperse :: Property
prop_intersperse = forAll ( genListMonStr >*< (arbitrary :: Gen(Int)) ) $
                       \((l, ms),n) -> DL.intersperse n l === toList (intersperseMF (Just n) ms)
 
genPrefixListMonStr :: Gen (([Int], [Int]), (MonStr Maybe Int, MonStr Maybe Int))
genPrefixListMonStr = do b <- (arbitrary :: Gen Bool)
                         l <- (listOf1 (arbitrary :: Gen Int))
                         l2 <- (listOf1 (arbitrary :: Gen Int))
                         i <- choose (0, length l)
                         if not b then return ((l2, l),(llist l2, llist l))
                                  else let p = take i l in
                                          return ((p, l), (llist p, llist l)) 
 
-- PASSES
prop_isPrefixOf :: Property
prop_isPrefixOf = forAll genPrefixListMonStr $
                     \((p,l), (ps, ms)) -> Just (isPrefixOf p l) === isPrefixOfMF ps ms


genElemListMonStr :: Gen ([Int], MonStr Maybe Int, Int)
genElemListMonStr = do (l,ms) <- genListMonStr
                       b <- (arbitrary :: Gen Bool)
                       i <- arbitrary
                       n <- choose (0, (length l) - 1)
                       return $ if b then (l, ms, i) else (l, ms, l DL.!! n)

-- PASSES
prop_elemIndex :: Property
prop_elemIndex = forAll genElemListMonStr $
                    \(l,ms,n) -> elemIndex n l === elemIndexM n ms

-- PASSES
prop_elemIndicies :: Property
prop_elemIndicies = forAll genElemListMonStr $
                       \(l,ms,n) -> elemIndices n l === toList (elemIndicesM n ms)

-- PASSES - not entirely sure if the generated functions give any non-trivial results
prop_findIndex :: Property
prop_findIndex = forAll ( genListMonStr >*< (arbitrary :: Gen(Fun Int Bool)) ) $
                    \((l, ms), (Fn p)) -> findIndex p l === findIndexM p ms

-- PASSES - not entirely sure if the generated functions give any non-trivial results
prop_findIndicies :: Property
prop_findIndicies = forAll ( genListMonStr >*< (arbitrary :: Gen(Fun Int Bool)) ) $
                       \((l, ms), (Fn p)) -> findIndices p l === toList (findIndicesM p ms)

genCharListMonStr :: Gen ([Char], MonStr Maybe Char)
genCharListMonStr = do l <- (listOf1 arbChar)
                       return (l, llist l)
                    where arbChar = frequency [(1, return ' '),(1, return '\n'),(5, arbitrary :: Gen Char)]

-- | These four may occasionally fail because specific special
-- characters that are interpreted by the stdlib versions as 
-- spaces or newlines are not included in our implementation.
-- This will not affect most use cases.

-- PASSES
prop_words :: Property
prop_words = forAll genCharListMonStr $
                \(l, ms) -> words l === toList (wordsMFL ms)

-- PASSES
prop_lines :: Property
prop_lines = forAll genCharListMonStr $
                \(l, ms) -> lines l === toList (linesMFL ms)

-- PASSES
prop_unwords :: Property
prop_unwords = forAll genCharListMonStr $
                  \(l, ms) -> unwords (words l) === toList (unwordsMFL (wordsMFL ms))

-- PASSES
prop_unlines :: Property
prop_unlines = forAll genCharListMonStr $
                  \(l, ms) -> unlines (lines l) === toList (unlinesMFL (linesMFL ms))

---- Runs all tests ----
return []
runTests :: IO ()
runTests = do b <- $quickCheckAll
              putStrLn (if b then "All tests passed!" else "Some tests failed!")